// Code generated by protoc-gen-go.
// source: customer.proto
// DO NOT EDIT!

/*
Package customer is a generated protocol buffer package.

It is generated from these files:
	customer.proto

It has these top-level messages:
	ReportRequest
	ReportResponse
	SetConfigRequest
	SetConfigResponse
	GetConfigRequest
	GetBudgetRemainRequest
	GetBudgetRemainResponse
	SetCampaignInactiveRequest
	SetCampaignInactiveResponse
	Customer
	Advertiser
	Campaign
	Native
	Creative
	Targeting
*/
package customer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ReportType int32

const (
	// Please use the basic reports if you need the only impressions and clicks events information with the basic fields and slices.
	ReportType_basic ReportType = 0
	// For adding the bids events in reports and using custom slices please use the advanced reports instead.
	// Please be note, that advanced reports usage may cause the additional billing and have to be approved by your manager.
	ReportType_advanced ReportType = 1
)

var ReportType_name = map[int32]string{
	0: "basic",
	1: "advanced",
}
var ReportType_value = map[string]int32{
	"basic":    0,
	"advanced": 1,
}

func (x ReportType) String() string {
	return proto.EnumName(ReportType_name, int32(x))
}
func (ReportType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type CreativeType int32

const (
	CreativeType_third_party_banner CreativeType = 0
	CreativeType_third_party_video  CreativeType = 1
	CreativeType_native             CreativeType = 2
	CreativeType_banner             CreativeType = 3
	CreativeType_interstitial       CreativeType = 4
	CreativeType_video              CreativeType = 5
	CreativeType_popunder           CreativeType = 6
)

var CreativeType_name = map[int32]string{
	0: "third_party_banner",
	1: "third_party_video",
	2: "native",
	3: "banner",
	4: "interstitial",
	5: "video",
	6: "popunder",
}
var CreativeType_value = map[string]int32{
	"third_party_banner": 0,
	"third_party_video":  1,
	"native":             2,
	"banner":             3,
	"interstitial":       4,
	"video":              5,
	"popunder":           6,
}

func (x CreativeType) String() string {
	return proto.EnumName(CreativeType_name, int32(x))
}
func (CreativeType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type Network int32

const (
	Network_bidswitch   Network = 0
	Network_google      Network = 1
	Network_mirs        Network = 2
	Network_advmaker    Network = 3
	Network_smartrtb    Network = 4
	Network_otm         Network = 5
	Network_smartyads   Network = 6
	Network_xapads      Network = 7
	Network_appodeal    Network = 8
	Network_pixfuture   Network = 9
	Network_bizzclick   Network = 10
	Network_stroeer     Network = 11
	Network_bidsxchange Network = 12
	Network_adkernel    Network = 13
	Network_mars        Network = 14
	Network_adthink     Network = 15
	Network_vertoz      Network = 16
	Network_aol         Network = 17
	Network_between     Network = 18
	Network_clickty     Network = 19
	Network_arteebee    Network = 20
	Network_zeropark    Network = 21
)

var Network_name = map[int32]string{
	0:  "bidswitch",
	1:  "google",
	2:  "mirs",
	3:  "advmaker",
	4:  "smartrtb",
	5:  "otm",
	6:  "smartyads",
	7:  "xapads",
	8:  "appodeal",
	9:  "pixfuture",
	10: "bizzclick",
	11: "stroeer",
	12: "bidsxchange",
	13: "adkernel",
	14: "mars",
	15: "adthink",
	16: "vertoz",
	17: "aol",
	18: "between",
	19: "clickty",
	20: "arteebee",
	21: "zeropark",
}
var Network_value = map[string]int32{
	"bidswitch":   0,
	"google":      1,
	"mirs":        2,
	"advmaker":    3,
	"smartrtb":    4,
	"otm":         5,
	"smartyads":   6,
	"xapads":      7,
	"appodeal":    8,
	"pixfuture":   9,
	"bizzclick":   10,
	"stroeer":     11,
	"bidsxchange": 12,
	"adkernel":    13,
	"mars":        14,
	"adthink":     15,
	"vertoz":      16,
	"aol":         17,
	"between":     18,
	"clickty":     19,
	"arteebee":    20,
	"zeropark":    21,
}

func (x Network) String() string {
	return proto.EnumName(Network_name, int32(x))
}
func (Network) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type ReportRequest struct {
	ClientId string `protobuf:"bytes,1,opt,name=client_id,json=clientId" json:"client_id,omitempty"`
	// From date in the 'YYYY-MM-DD' format
	FromDate string `protobuf:"bytes,2,opt,name=from_date,json=fromDate" json:"from_date,omitempty"`
	// To date in the 'YYYY-MM-DD' format
	ToDate string `protobuf:"bytes,3,opt,name=to_date,json=toDate" json:"to_date,omitempty"`
	// Available output formats: Pretty, JSON, CSV[WithNames], TabSeparated[WithNames[AndTypes]], XML (default "Pretty")
	Format string `protobuf:"bytes,4,opt,name=format" json:"format,omitempty"`
	// CampaignID in the 'AdvertiserID.CampaignID' format
	CampaignId string `protobuf:"bytes,5,opt,name=campaign_id,json=campaignId" json:"campaign_id,omitempty"`
	// Available values for "basic" reports: ssp, creative_id, campaign_id, date, app_bundle, hour. Additionally available for "advanced" reports: pub_id, app_id, country, carrier, os, domain.
	GroupBy []string `protobuf:"bytes,7,rep,name=group_by,json=groupBy" json:"group_by,omitempty"`
	// Available values for "basic" reports: date, campaign_id, creative_id, imps, clicks, ctr, cost, cpm, cpc, app_bundle, hour.  Additionally available for "advanced" reports: bids, win_rate.
	OrderBy []string `protobuf:"bytes,8,rep,name=order_by,json=orderBy" json:"order_by,omitempty"`
	// Determine the input/output data formats. By default is "basic" reports.
	Type ReportType `protobuf:"varint,9,opt,name=type,enum=customer.ReportType" json:"type,omitempty"`
}

func (m *ReportRequest) Reset()                    { *m = ReportRequest{} }
func (m *ReportRequest) String() string            { return proto.CompactTextString(m) }
func (*ReportRequest) ProtoMessage()               {}
func (*ReportRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ReportRequest) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *ReportRequest) GetFromDate() string {
	if m != nil {
		return m.FromDate
	}
	return ""
}

func (m *ReportRequest) GetToDate() string {
	if m != nil {
		return m.ToDate
	}
	return ""
}

func (m *ReportRequest) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *ReportRequest) GetCampaignId() string {
	if m != nil {
		return m.CampaignId
	}
	return ""
}

func (m *ReportRequest) GetGroupBy() []string {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *ReportRequest) GetOrderBy() []string {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *ReportRequest) GetType() ReportType {
	if m != nil {
		return m.Type
	}
	return ReportType_basic
}

type ReportResponse struct {
	Data string `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *ReportResponse) Reset()                    { *m = ReportResponse{} }
func (m *ReportResponse) String() string            { return proto.CompactTextString(m) }
func (*ReportResponse) ProtoMessage()               {}
func (*ReportResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ReportResponse) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type SetConfigRequest struct {
	Customer *Customer `protobuf:"bytes,1,opt,name=customer" json:"customer,omitempty"`
}

func (m *SetConfigRequest) Reset()                    { *m = SetConfigRequest{} }
func (m *SetConfigRequest) String() string            { return proto.CompactTextString(m) }
func (*SetConfigRequest) ProtoMessage()               {}
func (*SetConfigRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SetConfigRequest) GetCustomer() *Customer {
	if m != nil {
		return m.Customer
	}
	return nil
}

type SetConfigResponse struct {
	Data string `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *SetConfigResponse) Reset()                    { *m = SetConfigResponse{} }
func (m *SetConfigResponse) String() string            { return proto.CompactTextString(m) }
func (*SetConfigResponse) ProtoMessage()               {}
func (*SetConfigResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SetConfigResponse) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type GetConfigRequest struct {
}

func (m *GetConfigRequest) Reset()                    { *m = GetConfigRequest{} }
func (m *GetConfigRequest) String() string            { return proto.CompactTextString(m) }
func (*GetConfigRequest) ProtoMessage()               {}
func (*GetConfigRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type GetBudgetRemainRequest struct {
}

func (m *GetBudgetRemainRequest) Reset()                    { *m = GetBudgetRemainRequest{} }
func (m *GetBudgetRemainRequest) String() string            { return proto.CompactTextString(m) }
func (*GetBudgetRemainRequest) ProtoMessage()               {}
func (*GetBudgetRemainRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type GetBudgetRemainResponse struct {
	ClientId string  `protobuf:"bytes,1,opt,name=client_id,json=clientId" json:"client_id,omitempty"`
	Budget   float32 `protobuf:"fixed32,2,opt,name=budget" json:"budget,omitempty"`
}

func (m *GetBudgetRemainResponse) Reset()                    { *m = GetBudgetRemainResponse{} }
func (m *GetBudgetRemainResponse) String() string            { return proto.CompactTextString(m) }
func (*GetBudgetRemainResponse) ProtoMessage()               {}
func (*GetBudgetRemainResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GetBudgetRemainResponse) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *GetBudgetRemainResponse) GetBudget() float32 {
	if m != nil {
		return m.Budget
	}
	return 0
}

type SetCampaignInactiveRequest struct {
	CampaignId string `protobuf:"bytes,1,opt,name=campaign_id,json=campaignId" json:"campaign_id,omitempty"`
	Inactive   bool   `protobuf:"varint,2,opt,name=inactive" json:"inactive,omitempty"`
}

func (m *SetCampaignInactiveRequest) Reset()                    { *m = SetCampaignInactiveRequest{} }
func (m *SetCampaignInactiveRequest) String() string            { return proto.CompactTextString(m) }
func (*SetCampaignInactiveRequest) ProtoMessage()               {}
func (*SetCampaignInactiveRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *SetCampaignInactiveRequest) GetCampaignId() string {
	if m != nil {
		return m.CampaignId
	}
	return ""
}

func (m *SetCampaignInactiveRequest) GetInactive() bool {
	if m != nil {
		return m.Inactive
	}
	return false
}

type SetCampaignInactiveResponse struct {
	CampaignId string `protobuf:"bytes,1,opt,name=campaign_id,json=campaignId" json:"campaign_id,omitempty"`
	Inactive   bool   `protobuf:"varint,2,opt,name=inactive" json:"inactive,omitempty"`
}

func (m *SetCampaignInactiveResponse) Reset()                    { *m = SetCampaignInactiveResponse{} }
func (m *SetCampaignInactiveResponse) String() string            { return proto.CompactTextString(m) }
func (*SetCampaignInactiveResponse) ProtoMessage()               {}
func (*SetCampaignInactiveResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *SetCampaignInactiveResponse) GetCampaignId() string {
	if m != nil {
		return m.CampaignId
	}
	return ""
}

func (m *SetCampaignInactiveResponse) GetInactive() bool {
	if m != nil {
		return m.Inactive
	}
	return false
}

type Customer struct {
	// There should be at least one advertiser in the config.
	Advertisers map[string]*Advertiser `protobuf:"bytes,1,rep,name=advertisers" json:"advertisers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Customer) Reset()                    { *m = Customer{} }
func (m *Customer) String() string            { return proto.CompactTextString(m) }
func (*Customer) ProtoMessage()               {}
func (*Customer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Customer) GetAdvertisers() map[string]*Advertiser {
	if m != nil {
		return m.Advertisers
	}
	return nil
}

type Advertiser struct {
	// This field is passed to the bid response for the required networks.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// There should be at least one campaign for each advertiser.
	Campaigns map[string]*Campaign `protobuf:"bytes,2,rep,name=campaigns" json:"campaigns,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// There should be at least one creative for each advertiser.
	Creatives map[string]*Creative `protobuf:"bytes,3,rep,name=creatives" json:"creatives,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// This field is passed to the bid response for the required networks.
	Agency string `protobuf:"bytes,4,opt,name=agency" json:"agency,omitempty"`
}

func (m *Advertiser) Reset()                    { *m = Advertiser{} }
func (m *Advertiser) String() string            { return proto.CompactTextString(m) }
func (*Advertiser) ProtoMessage()               {}
func (*Advertiser) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Advertiser) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Advertiser) GetCampaigns() map[string]*Campaign {
	if m != nil {
		return m.Campaigns
	}
	return nil
}

func (m *Advertiser) GetCreatives() map[string]*Creative {
	if m != nil {
		return m.Creatives
	}
	return nil
}

func (m *Advertiser) GetAgency() string {
	if m != nil {
		return m.Agency
	}
	return ""
}

type Campaign struct {
	// System extention fields. Do not Edit.
	Id        string   `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	ClientId  string   `protobuf:"bytes,3,opt,name=client_id,json=clientId" json:"client_id,omitempty"`
	Name      string   `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Creatives []string `protobuf:"bytes,4,rep,name=creatives" json:"creatives,omitempty"`
	// IAB content categories of the campaign. Refer to List 5.1 in the openRTB spec.
	// This is sent in the bid response as the "cat" field.
	// This is compared with the "bcat" field in the bid request. If matched - the campaign is not bidded.
	Category []string          `protobuf:"bytes,5,rep,name=category" json:"category,omitempty"`
	Pricing  *Campaign_Pricing `protobuf:"bytes,6,opt,name=pricing" json:"pricing,omitempty"`
	Budget   *Campaign_Budget  `protobuf:"bytes,7,opt,name=budget" json:"budget,omitempty"`
	// Required. If campaign has no targetings, please pass the empty object like {}.
	Targeting *Targeting `protobuf:"bytes,8,opt,name=targeting" json:"targeting,omitempty"`
	// URL of the landing page without get parameters.
	// This is sent to the "adomain" bid response field.
	// The landing page's domain is compared with the "badv" field in the bid request. If matched - the campaign is not bidded.
	LandingPageUrl []string `protobuf:"bytes,9,rep,name=landing_page_url,json=landingPageUrl" json:"landing_page_url,omitempty"`
	// The URL which will be called on the impression.
	// {RANDOM} macros could be used for cachebusting.
	// Note: if the impression tracker doesn't have the valid SSL certificate - please populate the "creative.insecure" flag to TRUE to avoid the stats discrepancies
	ImpressionTrackingUrl string `protobuf:"bytes,10,opt,name=impression_tracking_url,json=impressionTrackingUrl" json:"impression_tracking_url,omitempty"`
	// Please populate this flag to TRUE if you need to pause the campaign without deleting it from the config.
	Inactive bool `protobuf:"varint,13,opt,name=inactive" json:"inactive,omitempty"`
	// Please don't use this option without your manager confirmation.
	BudgetTargeting bool `protobuf:"varint,14,opt,name=budget_targeting,json=budgetTargeting" json:"budget_targeting,omitempty"`
	// Campaign start date in the YYYY-MM-DD format. Working in the UTC+3 timezone.
	StartDate string `protobuf:"bytes,15,opt,name=start_date,json=startDate" json:"start_date,omitempty"`
	// Campaign stop date in the YYYY-MM-DD format. Working in the UTC+3 timezone.
	// Please note that campaign is active during all the stop date mentioned day.
	StopDate string `protobuf:"bytes,16,opt,name=stop_date,json=stopDate" json:"stop_date,omitempty"`
	// Campaign serving hours. Values could vary from 0 to 23. Working in the UTC+3 timezone.
	ServingHours []int64 `protobuf:"varint,17,rep,packed,name=serving_hours,json=servingHours" json:"serving_hours,omitempty"`
}

func (m *Campaign) Reset()                    { *m = Campaign{} }
func (m *Campaign) String() string            { return proto.CompactTextString(m) }
func (*Campaign) ProtoMessage()               {}
func (*Campaign) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Campaign) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Campaign) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *Campaign) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Campaign) GetCreatives() []string {
	if m != nil {
		return m.Creatives
	}
	return nil
}

func (m *Campaign) GetCategory() []string {
	if m != nil {
		return m.Category
	}
	return nil
}

func (m *Campaign) GetPricing() *Campaign_Pricing {
	if m != nil {
		return m.Pricing
	}
	return nil
}

func (m *Campaign) GetBudget() *Campaign_Budget {
	if m != nil {
		return m.Budget
	}
	return nil
}

func (m *Campaign) GetTargeting() *Targeting {
	if m != nil {
		return m.Targeting
	}
	return nil
}

func (m *Campaign) GetLandingPageUrl() []string {
	if m != nil {
		return m.LandingPageUrl
	}
	return nil
}

func (m *Campaign) GetImpressionTrackingUrl() string {
	if m != nil {
		return m.ImpressionTrackingUrl
	}
	return ""
}

func (m *Campaign) GetInactive() bool {
	if m != nil {
		return m.Inactive
	}
	return false
}

func (m *Campaign) GetBudgetTargeting() bool {
	if m != nil {
		return m.BudgetTargeting
	}
	return false
}

func (m *Campaign) GetStartDate() string {
	if m != nil {
		return m.StartDate
	}
	return ""
}

func (m *Campaign) GetStopDate() string {
	if m != nil {
		return m.StopDate
	}
	return ""
}

func (m *Campaign) GetServingHours() []int64 {
	if m != nil {
		return m.ServingHours
	}
	return nil
}

// Required
type Campaign_Pricing struct {
	// This is compared against the 'cur' field of the bid request,
	// which contains ISO-4217 alpha codes of the currencies, allowed for the bid.
	// In case 'cur' is not populated in the bid request, it's compared against the default currency for the network (generally 'USD').
	Currency string `protobuf:"bytes,1,opt,name=currency" json:"currency,omitempty"`
	// This number is sent into the bid response as the bid CPM price.
	// This field is required and should be more then zero.
	Bid float64 `protobuf:"fixed64,2,opt,name=bid" json:"bid,omitempty"`
	// This number divided by 1,000 (CPM) the campaign budget is decreased on the impression.
	// This field is required and should be not less then pricing.bid
	Impression float64 `protobuf:"fixed64,3,opt,name=impression" json:"impression,omitempty"`
}

func (m *Campaign_Pricing) Reset()                    { *m = Campaign_Pricing{} }
func (m *Campaign_Pricing) String() string            { return proto.CompactTextString(m) }
func (*Campaign_Pricing) ProtoMessage()               {}
func (*Campaign_Pricing) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 0} }

func (m *Campaign_Pricing) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *Campaign_Pricing) GetBid() float64 {
	if m != nil {
		return m.Bid
	}
	return 0
}

func (m *Campaign_Pricing) GetImpression() float64 {
	if m != nil {
		return m.Impression
	}
	return 0
}

type Campaign_Budget struct {
	// Campaign daily budget limit. Daily budget is reseted every day at midnight by the UTC+3 (Moscow) time zone.
	// This field is required and should be more the zero.
	Daily float64 `protobuf:"fixed64,1,opt,name=daily" json:"daily,omitempty"`
	// Use this flag if campaign spends daily budget too fast.
	// It spreads the daily budget evenly during the day.
	Smooth bool `protobuf:"varint,2,opt,name=smooth" json:"smooth,omitempty"`
}

func (m *Campaign_Budget) Reset()                    { *m = Campaign_Budget{} }
func (m *Campaign_Budget) String() string            { return proto.CompactTextString(m) }
func (*Campaign_Budget) ProtoMessage()               {}
func (*Campaign_Budget) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 1} }

func (m *Campaign_Budget) GetDaily() float64 {
	if m != nil {
		return m.Daily
	}
	return 0
}

func (m *Campaign_Budget) GetSmooth() bool {
	if m != nil {
		return m.Smooth
	}
	return false
}

type Native struct {
	Assets []*Native_Asset `protobuf:"bytes,1,rep,name=assets" json:"assets,omitempty"`
}

func (m *Native) Reset()                    { *m = Native{} }
func (m *Native) String() string            { return proto.CompactTextString(m) }
func (*Native) ProtoMessage()               {}
func (*Native) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Native) GetAssets() []*Native_Asset {
	if m != nil {
		return m.Assets
	}
	return nil
}

type Native_Asset struct {
	Title *Native_Asset_Title `protobuf:"bytes,1,opt,name=title" json:"title,omitempty"`
	Image *Native_Asset_Image `protobuf:"bytes,2,opt,name=image" json:"image,omitempty"`
	Data  *Native_Asset_Data  `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
}

func (m *Native_Asset) Reset()                    { *m = Native_Asset{} }
func (m *Native_Asset) String() string            { return proto.CompactTextString(m) }
func (*Native_Asset) ProtoMessage()               {}
func (*Native_Asset) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 0} }

func (m *Native_Asset) GetTitle() *Native_Asset_Title {
	if m != nil {
		return m.Title
	}
	return nil
}

func (m *Native_Asset) GetImage() *Native_Asset_Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *Native_Asset) GetData() *Native_Asset_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type Native_Asset_Title struct {
	Text string `protobuf:"bytes,1,opt,name=text" json:"text,omitempty"`
}

func (m *Native_Asset_Title) Reset()                    { *m = Native_Asset_Title{} }
func (m *Native_Asset_Title) String() string            { return proto.CompactTextString(m) }
func (*Native_Asset_Title) ProtoMessage()               {}
func (*Native_Asset_Title) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 0, 0} }

func (m *Native_Asset_Title) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type Native_Asset_Image struct {
	Url    string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	Width  int64  `protobuf:"varint,2,opt,name=width" json:"width,omitempty"`
	Height int64  `protobuf:"varint,3,opt,name=height" json:"height,omitempty"`
	Mime   string `protobuf:"bytes,4,opt,name=mime" json:"mime,omitempty"`
}

func (m *Native_Asset_Image) Reset()                    { *m = Native_Asset_Image{} }
func (m *Native_Asset_Image) String() string            { return proto.CompactTextString(m) }
func (*Native_Asset_Image) ProtoMessage()               {}
func (*Native_Asset_Image) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 0, 1} }

func (m *Native_Asset_Image) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Native_Asset_Image) GetWidth() int64 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Native_Asset_Image) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Native_Asset_Image) GetMime() string {
	if m != nil {
		return m.Mime
	}
	return ""
}

type Native_Asset_Data struct {
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
	Type  int64  `protobuf:"varint,2,opt,name=type" json:"type,omitempty"`
}

func (m *Native_Asset_Data) Reset()                    { *m = Native_Asset_Data{} }
func (m *Native_Asset_Data) String() string            { return proto.CompactTextString(m) }
func (*Native_Asset_Data) ProtoMessage()               {}
func (*Native_Asset_Data) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 0, 2} }

func (m *Native_Asset_Data) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Native_Asset_Data) GetType() int64 {
	if m != nil {
		return m.Type
	}
	return 0
}

type Creative struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Please ignore this field.
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// Please ignore this field.
	AdId string `protobuf:"bytes,3,opt,name=ad_id,json=adId" json:"ad_id,omitempty"`
	// Please populate this flag to TRUE in case the creative code has the "http://" requests
	// or impression_tracking_url doesn't have the valid SSL certificate.
	// Please note that some ad networks (google for example) require all the served content to be secured.
	// For those networks you will not receive bids for the creatives with the insecure flag populated.
	Insecure bool         `protobuf:"varint,4,opt,name=insecure" json:"insecure,omitempty"`
	Type     CreativeType `protobuf:"varint,5,opt,name=type,enum=customer.CreativeType" json:"type,omitempty"`
	// URL the user will be sent to on click. Should contains the protocol (http:// or https://).
	// This is required for the creatives which should be rotated in the Google Ad Exchange.
	// If you use some ad server you might need to generate the click URL dynamic on the banner render.
	// For this just put the escaped version of the click URL in the creative code right after the click macro instead of populate it in this field.
	// Valid example: {CLICK_URL}http%3A%2F%2Flanding-page.com
	// Invalid example: {CLICK_URL}http://landing-page.com
	// IMPORTANT! Please never use both ways simultaneously - you need either specify click URL in the "click_url" field or populate it in the creative code itself, but not both ways at once!
	ClickUrl string         `protobuf:"bytes,6,opt,name=click_url,json=clickUrl" json:"click_url,omitempty"`
	Size     *Creative_Size `protobuf:"bytes,7,opt,name=size" json:"size,omitempty"`
	// Creative's html snippet. Should contains valid html code.
	// This field could contains the following macros:
	// {CLICK_URL} will be resolved to the click URL handler.
	// {CLICK_URL_ESC} will be resolved to the escaped click URL handler.
	// {PUB_ID} will be resolved to the publisher id.
	// Note: either {CLICK_URL} or {CLICK_URL_ESC} is required for the creatives which should be rotated in the Google Ad Exchange.
	// This field size should not exceed 8Kb.
	HtmlContent string `protobuf:"bytes,8,opt,name=html_content,json=htmlContent" json:"html_content,omitempty"`
	// Creative's MIME type. This is compared with the "banner.mimes" field in the bid request.
	// If no matches - creative is not eligible for bid.
	Mimes  []string `protobuf:"bytes,10,rep,name=mimes" json:"mimes,omitempty"`
	Native *Native  `protobuf:"bytes,13,opt,name=native" json:"native,omitempty"`
	// IAB creative attributes. Refer to List 5.3 in the openRTB spec.
	// This is sent in the bid response in the "bid.attr" field.
	// This is compared with the "battr" field in the bid request. If matched - the creative is not bidded.
	Attributes []int64 `protobuf:"varint,14,rep,packed,name=attributes" json:"attributes,omitempty"`
	// Please use that variable to populate the custom click marco which will be replaced into the "html_content" field.
	// If you don't populate it, you can still use the default click macro: {CLICK_URL}
	ClickMacros string `protobuf:"bytes,16,opt,name=click_macros,json=clickMacros" json:"click_macros,omitempty"`
	// Please use that variable to populate the custom escaped click marco which will be replaced into the "html_content" field.
	// If you don't populate it, you can still use the default click macro: {CLICK_URL_ESC}
	ClickMacrosEsc string          `protobuf:"bytes,17,opt,name=click_macros_esc,json=clickMacrosEsc" json:"click_macros_esc,omitempty"`
	Video          *Creative_Video `protobuf:"bytes,18,opt,name=video" json:"video,omitempty"`
	// Banner ad types. Refer to List 5.2 in the openRTB spec.
	// This is compared with the "btype" field in the bid request. If matched - the creative is not bidded.
	HtmlTags []int64 `protobuf:"varint,19,rep,packed,name=html_tags,json=htmlTags" json:"html_tags,omitempty"`
	// Field is mandatory for the popunder creative type.
	// Should be valid URL.
	Url string `protobuf:"bytes,20,opt,name=url" json:"url,omitempty"`
}

func (m *Creative) Reset()                    { *m = Creative{} }
func (m *Creative) String() string            { return proto.CompactTextString(m) }
func (*Creative) ProtoMessage()               {}
func (*Creative) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Creative) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Creative) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Creative) GetAdId() string {
	if m != nil {
		return m.AdId
	}
	return ""
}

func (m *Creative) GetInsecure() bool {
	if m != nil {
		return m.Insecure
	}
	return false
}

func (m *Creative) GetType() CreativeType {
	if m != nil {
		return m.Type
	}
	return CreativeType_third_party_banner
}

func (m *Creative) GetClickUrl() string {
	if m != nil {
		return m.ClickUrl
	}
	return ""
}

func (m *Creative) GetSize() *Creative_Size {
	if m != nil {
		return m.Size
	}
	return nil
}

func (m *Creative) GetHtmlContent() string {
	if m != nil {
		return m.HtmlContent
	}
	return ""
}

func (m *Creative) GetMimes() []string {
	if m != nil {
		return m.Mimes
	}
	return nil
}

func (m *Creative) GetNative() *Native {
	if m != nil {
		return m.Native
	}
	return nil
}

func (m *Creative) GetAttributes() []int64 {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Creative) GetClickMacros() string {
	if m != nil {
		return m.ClickMacros
	}
	return ""
}

func (m *Creative) GetClickMacrosEsc() string {
	if m != nil {
		return m.ClickMacrosEsc
	}
	return ""
}

func (m *Creative) GetVideo() *Creative_Video {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *Creative) GetHtmlTags() []int64 {
	if m != nil {
		return m.HtmlTags
	}
	return nil
}

func (m *Creative) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type Creative_Size struct {
	Width  int64 `protobuf:"varint,1,opt,name=width" json:"width,omitempty"`
	Height int64 `protobuf:"varint,2,opt,name=height" json:"height,omitempty"`
}

func (m *Creative_Size) Reset()                    { *m = Creative_Size{} }
func (m *Creative_Size) String() string            { return proto.CompactTextString(m) }
func (*Creative_Size) ProtoMessage()               {}
func (*Creative_Size) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13, 0} }

func (m *Creative_Size) GetWidth() int64 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Creative_Size) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type Creative_Video struct {
	// Video ad duration in seconds. Required for the creative type "third_party_video".
	// This is compared with the "video.minduration" and "video.maxduration" fields in the bid request.
	// Creative's duration should be between these values to be eligible for bid.
	Duration int64 `protobuf:"varint,1,opt,name=duration" json:"duration,omitempty"`
	// Supported video protocols. Required for the creative type "third_party_video". Refer to List 5.8 in the Open RTB spec.
	// This is compared with the "video.protocols" field in the bid request.
	// If no matches - creative is not eligible for bid.
	Protocols []int64 `protobuf:"varint,2,rep,packed,name=protocols" json:"protocols,omitempty"`
	// The URL which returns the valid VAST XML.
	// Required for the creative type "third_party_video".
	VastUrl string `protobuf:"bytes,3,opt,name=vast_url,json=vastUrl" json:"vast_url,omitempty"`
	// Number of seconds before the SKIP button is appeared in the video ad.
	// Mandatory for the skippable video creatives.
	Skipoffset int64                  `protobuf:"varint,4,opt,name=skipoffset" json:"skipoffset,omitempty"`
	Files      []*Creative_Video_File `protobuf:"bytes,5,rep,name=files" json:"files,omitempty"`
}

func (m *Creative_Video) Reset()                    { *m = Creative_Video{} }
func (m *Creative_Video) String() string            { return proto.CompactTextString(m) }
func (*Creative_Video) ProtoMessage()               {}
func (*Creative_Video) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13, 1} }

func (m *Creative_Video) GetDuration() int64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Creative_Video) GetProtocols() []int64 {
	if m != nil {
		return m.Protocols
	}
	return nil
}

func (m *Creative_Video) GetVastUrl() string {
	if m != nil {
		return m.VastUrl
	}
	return ""
}

func (m *Creative_Video) GetSkipoffset() int64 {
	if m != nil {
		return m.Skipoffset
	}
	return 0
}

func (m *Creative_Video) GetFiles() []*Creative_Video_File {
	if m != nil {
		return m.Files
	}
	return nil
}

type Creative_Video_File struct {
	Mime string `protobuf:"bytes,1,opt,name=mime" json:"mime,omitempty"`
	Url  string `protobuf:"bytes,2,opt,name=url" json:"url,omitempty"`
}

func (m *Creative_Video_File) Reset()                    { *m = Creative_Video_File{} }
func (m *Creative_Video_File) String() string            { return proto.CompactTextString(m) }
func (*Creative_Video_File) ProtoMessage()               {}
func (*Creative_Video_File) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13, 1, 0} }

func (m *Creative_Video_File) GetMime() string {
	if m != nil {
		return m.Mime
	}
	return ""
}

func (m *Creative_Video_File) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type Targeting struct {
	// This targeting works by the data network provides in the 'device.geo' object of the bid request.
	// If network doesn't provide such info (for example Stroeer) - please use the 'geo_ip' targeting instead.
	// Please note, that you have to populate the country code in the exact format the network passes it.
	// Some networks pass the ISO-3166-1 Alpha-2 codes, some pass the ISO-3166-1 Alpha-3 codes.
	// If you are not sure what exact format the network passes- just use the both ways, for example ["US","USA"]
	Geo *Targeting_Geo  `protobuf:"bytes,1,opt,name=geo" json:"geo,omitempty"`
	Os  []*Targeting_OS `protobuf:"bytes,2,rep,name=os" json:"os,omitempty"`
	// The minimum delay between any two impressions for the single user in the one ad network in seconds.
	// Works by "user.id" field in the bid request. If "user.id" is null - works by the "device.ifa" field instead.
	Frequency int64 `protobuf:"varint,3,opt,name=frequency" json:"frequency,omitempty"`
	// Carrier or ISP as it's declared in the "device.carrier" field in the bid request.
	// For Google Ad Exchange use the Criterion ID string from this list to target: https://developers.google.com/adwords/api/docs/appendix/mobilecarriers.csv
	Carrier *Targeting_ListMatch `protobuf:"bytes,5,opt,name=carrier" json:"carrier,omitempty"`
	// IAB content categories as it's declared in the "site.cat" or "app.cat" fields in the bid request.
	Category *Targeting_ListMatch `protobuf:"bytes,6,opt,name=category" json:"category,omitempty"`
	// The general type of device as it's declared in the "device.devicetype" field in the bid request.
	// Refer to List 5.17 in the Open RTB spec.
	DeviceType *Targeting_ListMatch `protobuf:"bytes,7,opt,name=device_type,json=deviceType" json:"device_type,omitempty"`
	// Site's domain is extracted from the "site.page" field in the bid request and compared with the populated list.
	Domain *Targeting_ListMatch `protobuf:"bytes,8,opt,name=domain" json:"domain,omitempty"`
	// This targeting works by the strings formatted as the {PUB_ID} macro returns: https://github.com/TheBridgeLLC/customer/wiki/Macros
	// Currently for all the networks except bidswitch and google it looks like 'SSP_PublisherID' string.
	Publisher *Targeting_ListMatch `protobuf:"bytes,9,opt,name=publisher" json:"publisher,omitempty"`
	// Works by the "ext.ssp" field for the Bidswitch's request.
	// Works by the "ext.exchange" field for the SmartRTB's request.
	Ssp    *Targeting_ListMatch `protobuf:"bytes,10,opt,name=ssp" json:"ssp,omitempty"`
	Google *Targeting_Google    `protobuf:"bytes,11,opt,name=google" json:"google,omitempty"`
	// Connected ad networks targeting. Please ask your account manager to obtain the available networks list.
	Network *Targeting_ListMatch `protobuf:"bytes,12,opt,name=network" json:"network,omitempty"`
	// Please use the "255.255.255.255/n" format for the ip ranges where "n" is the number of the first bits in the subnet mask.
	// For example "20.78.168.0/21" represents IPv4 addresses between "220.78.168.0" and "220.78.175.255"
	RangeIp []string `protobuf:"bytes,14,rep,name=range_ip,json=rangeIp" json:"range_ip,omitempty"`
	// This targeting search the substring into the "site.page" field of the bid request.
	// For example if you target to include the "news.ru/sport" string,
	// the site.page "http://www.news.ru/sports-and-hobbies/article.html" will pass
	// and the "http://www.news.ru/team-sport" will not.
	UrlContains *Targeting_ListMatch `protobuf:"bytes,15,opt,name=url_contains,json=urlContains" json:"url_contains,omitempty"`
	// Works by the "site.id" field in the bid request.
	SiteId *Targeting_ListMatch `protobuf:"bytes,16,opt,name=site_id,json=siteId" json:"site_id,omitempty"`
	// Works by the "app.id" field in the bid request.
	AppId *Targeting_ListMatch `protobuf:"bytes,17,opt,name=app_id,json=appId" json:"app_id,omitempty"`
	// Works by the "app.bundle" field in the bid request.
	AppBundle *Targeting_ListMatch `protobuf:"bytes,18,opt,name=app_bundle,json=appBundle" json:"app_bundle,omitempty"`
	// The type of device connectivity as it's declared in the "device.connectiontype" field in the bid request.
	// Refer to List 5.22 in the Open RTB spec.
	DeviceConnectionType *Targeting_ListMatch `protobuf:"bytes,19,opt,name=device_connection_type,json=deviceConnectionType" json:"device_connection_type,omitempty"`
	// There are two valid values: "web" and "app".
	// If "web" is included - we bid if request contains "site" object.
	// If "app" is included - we bid if request contains "app" object.
	InventoryType *Targeting_ListMatch `protobuf:"bytes,20,opt,name=inventory_type,json=inventoryType" json:"inventory_type,omitempty"`
	// Allow to target users by your own custom IP list.
	// To add your ip list in the bidder please contact with your manager.
	CustomIpRange bool `protobuf:"varint,21,opt,name=custom_ip_range,json=customIpRange" json:"custom_ip_range,omitempty"`
	// Please use this targeting if you have more then one endpoint for the connected network.
	// To create the additional endpoints for the connected network please contact your manager.
	NetworkPrefix []string `protobuf:"bytes,22,rep,name=network_prefix,json=networkPrefix" json:"network_prefix,omitempty"`
	// Available browser names: "Opera", "Edge", "Chrome", "Safari", "Internet Explorer", "Firefox",
	// "Opera mobile", "Edge mobile", "Chrome mobile", "Safari mobile", "Internet Explorer mobile", "Firefox mobile", "Android mobile"
	Browser *Targeting_ListMatch `protobuf:"bytes,23,opt,name=browser" json:"browser,omitempty"`
	// Please use this targeting instead of the 'geo' in case you wish us to determine user's geo on our end by ip address.
	// Always use the ISO-3166-1 Alpha-2 country codes for this targeting.
	GeoIp *Targeting_Geo `protobuf:"bytes,24,opt,name=geo_ip,json=geoIp" json:"geo_ip,omitempty"`
	// Referrer's domain is extracted from the "site.ref" field in the bid request and compared with the populated list.
	Referrer *Targeting_ListMatch `protobuf:"bytes,25,opt,name=referrer" json:"referrer,omitempty"`
	// Use this option to target the only domains which contains the right network and publisher in the ads.txt file.
	// Please check more details about ads.txt initiative here: https://iabtechlab.com/ads-txt/
	AdsTxt bool `protobuf:"varint,26,opt,name=ads_txt,json=adsTxt" json:"ads_txt,omitempty"`
	// Allow to target campaigns by your own custom IP ranges list.
	// To add or modify your ip ranges list please contact your manager.
	IpRange   string                 `protobuf:"bytes,27,opt,name=ip_range,json=ipRange" json:"ip_range,omitempty"`
	UserAgent []*Targeting_UserAgent `protobuf:"bytes,28,rep,name=user_agent,json=userAgent" json:"user_agent,omitempty"`
	// Ad position as it's declared in the "imp.banner.pos" field in the bid request.
	// Refer to List 5.4 in the Open RTB spec.
	BannerPos *Targeting_ListMatch `protobuf:"bytes,29,opt,name=banner_pos,json=bannerPos" json:"banner_pos,omitempty"`
}

func (m *Targeting) Reset()                    { *m = Targeting{} }
func (m *Targeting) String() string            { return proto.CompactTextString(m) }
func (*Targeting) ProtoMessage()               {}
func (*Targeting) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Targeting) GetGeo() *Targeting_Geo {
	if m != nil {
		return m.Geo
	}
	return nil
}

func (m *Targeting) GetOs() []*Targeting_OS {
	if m != nil {
		return m.Os
	}
	return nil
}

func (m *Targeting) GetFrequency() int64 {
	if m != nil {
		return m.Frequency
	}
	return 0
}

func (m *Targeting) GetCarrier() *Targeting_ListMatch {
	if m != nil {
		return m.Carrier
	}
	return nil
}

func (m *Targeting) GetCategory() *Targeting_ListMatch {
	if m != nil {
		return m.Category
	}
	return nil
}

func (m *Targeting) GetDeviceType() *Targeting_ListMatch {
	if m != nil {
		return m.DeviceType
	}
	return nil
}

func (m *Targeting) GetDomain() *Targeting_ListMatch {
	if m != nil {
		return m.Domain
	}
	return nil
}

func (m *Targeting) GetPublisher() *Targeting_ListMatch {
	if m != nil {
		return m.Publisher
	}
	return nil
}

func (m *Targeting) GetSsp() *Targeting_ListMatch {
	if m != nil {
		return m.Ssp
	}
	return nil
}

func (m *Targeting) GetGoogle() *Targeting_Google {
	if m != nil {
		return m.Google
	}
	return nil
}

func (m *Targeting) GetNetwork() *Targeting_ListMatch {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *Targeting) GetRangeIp() []string {
	if m != nil {
		return m.RangeIp
	}
	return nil
}

func (m *Targeting) GetUrlContains() *Targeting_ListMatch {
	if m != nil {
		return m.UrlContains
	}
	return nil
}

func (m *Targeting) GetSiteId() *Targeting_ListMatch {
	if m != nil {
		return m.SiteId
	}
	return nil
}

func (m *Targeting) GetAppId() *Targeting_ListMatch {
	if m != nil {
		return m.AppId
	}
	return nil
}

func (m *Targeting) GetAppBundle() *Targeting_ListMatch {
	if m != nil {
		return m.AppBundle
	}
	return nil
}

func (m *Targeting) GetDeviceConnectionType() *Targeting_ListMatch {
	if m != nil {
		return m.DeviceConnectionType
	}
	return nil
}

func (m *Targeting) GetInventoryType() *Targeting_ListMatch {
	if m != nil {
		return m.InventoryType
	}
	return nil
}

func (m *Targeting) GetCustomIpRange() bool {
	if m != nil {
		return m.CustomIpRange
	}
	return false
}

func (m *Targeting) GetNetworkPrefix() []string {
	if m != nil {
		return m.NetworkPrefix
	}
	return nil
}

func (m *Targeting) GetBrowser() *Targeting_ListMatch {
	if m != nil {
		return m.Browser
	}
	return nil
}

func (m *Targeting) GetGeoIp() *Targeting_Geo {
	if m != nil {
		return m.GeoIp
	}
	return nil
}

func (m *Targeting) GetReferrer() *Targeting_ListMatch {
	if m != nil {
		return m.Referrer
	}
	return nil
}

func (m *Targeting) GetAdsTxt() bool {
	if m != nil {
		return m.AdsTxt
	}
	return false
}

func (m *Targeting) GetIpRange() string {
	if m != nil {
		return m.IpRange
	}
	return ""
}

func (m *Targeting) GetUserAgent() []*Targeting_UserAgent {
	if m != nil {
		return m.UserAgent
	}
	return nil
}

func (m *Targeting) GetBannerPos() *Targeting_ListMatch {
	if m != nil {
		return m.BannerPos
	}
	return nil
}

// Required for campaigns, which should be served in the Google Ad Exchange
type Targeting_Google struct {
	BillingId []string `protobuf:"bytes,2,rep,name=billing_id,json=billingId" json:"billing_id,omitempty"`
}

func (m *Targeting_Google) Reset()                    { *m = Targeting_Google{} }
func (m *Targeting_Google) String() string            { return proto.CompactTextString(m) }
func (*Targeting_Google) ProtoMessage()               {}
func (*Targeting_Google) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14, 0} }

func (m *Targeting_Google) GetBillingId() []string {
	if m != nil {
		return m.BillingId
	}
	return nil
}

type Targeting_Geo struct {
	// Country using ISO-3166-1 Alpha-2, for example NL
	Country *Targeting_ListMatch `protobuf:"bytes,1,opt,name=country" json:"country,omitempty"`
	// City name as provided by MaxMind, for example, Alkmaar
	City *Targeting_ListMatch `protobuf:"bytes,2,opt,name=city" json:"city,omitempty"`
	// Region using ISO-3166-2 or FIPS region codes, for example, 07
	Region *Targeting_ListMatch `protobuf:"bytes,3,opt,name=region" json:"region,omitempty"`
}

func (m *Targeting_Geo) Reset()                    { *m = Targeting_Geo{} }
func (m *Targeting_Geo) String() string            { return proto.CompactTextString(m) }
func (*Targeting_Geo) ProtoMessage()               {}
func (*Targeting_Geo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14, 1} }

func (m *Targeting_Geo) GetCountry() *Targeting_ListMatch {
	if m != nil {
		return m.Country
	}
	return nil
}

func (m *Targeting_Geo) GetCity() *Targeting_ListMatch {
	if m != nil {
		return m.City
	}
	return nil
}

func (m *Targeting_Geo) GetRegion() *Targeting_ListMatch {
	if m != nil {
		return m.Region
	}
	return nil
}

type Targeting_OS struct {
	// Device operating system as it's declared in the "device.os" field in the bid request. Not case sensitive.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Device operating system version as it's declared in the "device.osv" field in the bid request.
	Version string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
}

func (m *Targeting_OS) Reset()                    { *m = Targeting_OS{} }
func (m *Targeting_OS) String() string            { return proto.CompactTextString(m) }
func (*Targeting_OS) ProtoMessage()               {}
func (*Targeting_OS) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14, 2} }

func (m *Targeting_OS) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Targeting_OS) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

// If you require that the bid request should contains the non empty value in the exact field, use the '"required": true' flag.
type Targeting_ListMatch struct {
	Include  bool     `protobuf:"varint,1,opt,name=include" json:"include,omitempty"`
	List     []string `protobuf:"bytes,2,rep,name=list" json:"list,omitempty"`
	Required bool     `protobuf:"varint,3,opt,name=required" json:"required,omitempty"`
}

func (m *Targeting_ListMatch) Reset()                    { *m = Targeting_ListMatch{} }
func (m *Targeting_ListMatch) String() string            { return proto.CompactTextString(m) }
func (*Targeting_ListMatch) ProtoMessage()               {}
func (*Targeting_ListMatch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14, 3} }

func (m *Targeting_ListMatch) GetInclude() bool {
	if m != nil {
		return m.Include
	}
	return false
}

func (m *Targeting_ListMatch) GetList() []string {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *Targeting_ListMatch) GetRequired() bool {
	if m != nil {
		return m.Required
	}
	return false
}

type Targeting_UserAgent struct {
	// Please check the CSV formatted list of the available values for the browser_family and browser_major targetings here:
	// https://github.com/TheBridgeLLC/customer/wiki/Browser-targeting
	BrowserFamily *Targeting_ListMatch `protobuf:"bytes,1,opt,name=browser_family,json=browserFamily" json:"browser_family,omitempty"`
	BrowserMajor  *Targeting_ListMatch `protobuf:"bytes,2,opt,name=browser_major,json=browserMajor" json:"browser_major,omitempty"`
	// Please check the CSV formatted list of the available values for the os_family and os_major targetings here:
	// https://github.com/TheBridgeLLC/customer/wiki/OS-targeting
	OsFamily *Targeting_ListMatch `protobuf:"bytes,3,opt,name=os_family,json=osFamily" json:"os_family,omitempty"`
	OsMajor  *Targeting_ListMatch `protobuf:"bytes,4,opt,name=os_major,json=osMajor" json:"os_major,omitempty"`
	// Please check the CSV formatted list of the available values for the device_family targeting here:
	// https://github.com/TheBridgeLLC/customer/wiki/Device-targeting
	DeviceFamily *Targeting_ListMatch `protobuf:"bytes,5,opt,name=device_family,json=deviceFamily" json:"device_family,omitempty"`
}

func (m *Targeting_UserAgent) Reset()                    { *m = Targeting_UserAgent{} }
func (m *Targeting_UserAgent) String() string            { return proto.CompactTextString(m) }
func (*Targeting_UserAgent) ProtoMessage()               {}
func (*Targeting_UserAgent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14, 4} }

func (m *Targeting_UserAgent) GetBrowserFamily() *Targeting_ListMatch {
	if m != nil {
		return m.BrowserFamily
	}
	return nil
}

func (m *Targeting_UserAgent) GetBrowserMajor() *Targeting_ListMatch {
	if m != nil {
		return m.BrowserMajor
	}
	return nil
}

func (m *Targeting_UserAgent) GetOsFamily() *Targeting_ListMatch {
	if m != nil {
		return m.OsFamily
	}
	return nil
}

func (m *Targeting_UserAgent) GetOsMajor() *Targeting_ListMatch {
	if m != nil {
		return m.OsMajor
	}
	return nil
}

func (m *Targeting_UserAgent) GetDeviceFamily() *Targeting_ListMatch {
	if m != nil {
		return m.DeviceFamily
	}
	return nil
}

func init() {
	proto.RegisterType((*ReportRequest)(nil), "customer.ReportRequest")
	proto.RegisterType((*ReportResponse)(nil), "customer.ReportResponse")
	proto.RegisterType((*SetConfigRequest)(nil), "customer.SetConfigRequest")
	proto.RegisterType((*SetConfigResponse)(nil), "customer.SetConfigResponse")
	proto.RegisterType((*GetConfigRequest)(nil), "customer.GetConfigRequest")
	proto.RegisterType((*GetBudgetRemainRequest)(nil), "customer.GetBudgetRemainRequest")
	proto.RegisterType((*GetBudgetRemainResponse)(nil), "customer.GetBudgetRemainResponse")
	proto.RegisterType((*SetCampaignInactiveRequest)(nil), "customer.SetCampaignInactiveRequest")
	proto.RegisterType((*SetCampaignInactiveResponse)(nil), "customer.SetCampaignInactiveResponse")
	proto.RegisterType((*Customer)(nil), "customer.Customer")
	proto.RegisterType((*Advertiser)(nil), "customer.Advertiser")
	proto.RegisterType((*Campaign)(nil), "customer.Campaign")
	proto.RegisterType((*Campaign_Pricing)(nil), "customer.Campaign.Pricing")
	proto.RegisterType((*Campaign_Budget)(nil), "customer.Campaign.Budget")
	proto.RegisterType((*Native)(nil), "customer.Native")
	proto.RegisterType((*Native_Asset)(nil), "customer.Native.Asset")
	proto.RegisterType((*Native_Asset_Title)(nil), "customer.Native.Asset.Title")
	proto.RegisterType((*Native_Asset_Image)(nil), "customer.Native.Asset.Image")
	proto.RegisterType((*Native_Asset_Data)(nil), "customer.Native.Asset.Data")
	proto.RegisterType((*Creative)(nil), "customer.Creative")
	proto.RegisterType((*Creative_Size)(nil), "customer.Creative.Size")
	proto.RegisterType((*Creative_Video)(nil), "customer.Creative.Video")
	proto.RegisterType((*Creative_Video_File)(nil), "customer.Creative.Video.File")
	proto.RegisterType((*Targeting)(nil), "customer.Targeting")
	proto.RegisterType((*Targeting_Google)(nil), "customer.Targeting.Google")
	proto.RegisterType((*Targeting_Geo)(nil), "customer.Targeting.Geo")
	proto.RegisterType((*Targeting_OS)(nil), "customer.Targeting.OS")
	proto.RegisterType((*Targeting_ListMatch)(nil), "customer.Targeting.ListMatch")
	proto.RegisterType((*Targeting_UserAgent)(nil), "customer.Targeting.UserAgent")
	proto.RegisterEnum("customer.ReportType", ReportType_name, ReportType_value)
	proto.RegisterEnum("customer.CreativeType", CreativeType_name, CreativeType_value)
	proto.RegisterEnum("customer.Network", Network_name, Network_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for API service

type APIClient interface {
	// Return clients metricks for the specified client ID with breakdown by Campaign ID.
	Report(ctx context.Context, in *ReportRequest, opts ...grpc.CallOption) (*ReportResponse, error)
	SetConfig(ctx context.Context, in *SetConfigRequest, opts ...grpc.CallOption) (*SetConfigResponse, error)
	GetConfig(ctx context.Context, in *GetConfigRequest, opts ...grpc.CallOption) (*Customer, error)
	SetCampaignInactive(ctx context.Context, in *SetCampaignInactiveRequest, opts ...grpc.CallOption) (*SetCampaignInactiveResponse, error)
	GetBudgetRemain(ctx context.Context, in *GetBudgetRemainRequest, opts ...grpc.CallOption) (*GetBudgetRemainResponse, error)
}

type aPIClient struct {
	cc *grpc.ClientConn
}

func NewAPIClient(cc *grpc.ClientConn) APIClient {
	return &aPIClient{cc}
}

func (c *aPIClient) Report(ctx context.Context, in *ReportRequest, opts ...grpc.CallOption) (*ReportResponse, error) {
	out := new(ReportResponse)
	err := grpc.Invoke(ctx, "/customer.API/Report", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) SetConfig(ctx context.Context, in *SetConfigRequest, opts ...grpc.CallOption) (*SetConfigResponse, error) {
	out := new(SetConfigResponse)
	err := grpc.Invoke(ctx, "/customer.API/SetConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GetConfig(ctx context.Context, in *GetConfigRequest, opts ...grpc.CallOption) (*Customer, error) {
	out := new(Customer)
	err := grpc.Invoke(ctx, "/customer.API/GetConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) SetCampaignInactive(ctx context.Context, in *SetCampaignInactiveRequest, opts ...grpc.CallOption) (*SetCampaignInactiveResponse, error) {
	out := new(SetCampaignInactiveResponse)
	err := grpc.Invoke(ctx, "/customer.API/SetCampaignInactive", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GetBudgetRemain(ctx context.Context, in *GetBudgetRemainRequest, opts ...grpc.CallOption) (*GetBudgetRemainResponse, error) {
	out := new(GetBudgetRemainResponse)
	err := grpc.Invoke(ctx, "/customer.API/GetBudgetRemain", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for API service

type APIServer interface {
	// Return clients metricks for the specified client ID with breakdown by Campaign ID.
	Report(context.Context, *ReportRequest) (*ReportResponse, error)
	SetConfig(context.Context, *SetConfigRequest) (*SetConfigResponse, error)
	GetConfig(context.Context, *GetConfigRequest) (*Customer, error)
	SetCampaignInactive(context.Context, *SetCampaignInactiveRequest) (*SetCampaignInactiveResponse, error)
	GetBudgetRemain(context.Context, *GetBudgetRemainRequest) (*GetBudgetRemainResponse, error)
}

func RegisterAPIServer(s *grpc.Server, srv APIServer) {
	s.RegisterService(&_API_serviceDesc, srv)
}

func _API_Report_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).Report(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/customer.API/Report",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).Report(ctx, req.(*ReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_SetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).SetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/customer.API/SetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).SetConfig(ctx, req.(*SetConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/customer.API/GetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).GetConfig(ctx, req.(*GetConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_SetCampaignInactive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCampaignInactiveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).SetCampaignInactive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/customer.API/SetCampaignInactive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).SetCampaignInactive(ctx, req.(*SetCampaignInactiveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GetBudgetRemain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBudgetRemainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).GetBudgetRemain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/customer.API/GetBudgetRemain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).GetBudgetRemain(ctx, req.(*GetBudgetRemainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _API_serviceDesc = grpc.ServiceDesc{
	ServiceName: "customer.API",
	HandlerType: (*APIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Report",
			Handler:    _API_Report_Handler,
		},
		{
			MethodName: "SetConfig",
			Handler:    _API_SetConfig_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _API_GetConfig_Handler,
		},
		{
			MethodName: "SetCampaignInactive",
			Handler:    _API_SetCampaignInactive_Handler,
		},
		{
			MethodName: "GetBudgetRemain",
			Handler:    _API_GetBudgetRemain_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "customer.proto",
}

func init() { proto.RegisterFile("customer.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2395 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x58, 0xdb, 0x72, 0x23, 0xb7,
	0xd1, 0x5e, 0x9e, 0x87, 0x4d, 0x8a, 0xc2, 0x62, 0x77, 0xa5, 0xf1, 0xc8, 0xf6, 0xbf, 0xa6, 0x0f,
	0xbf, 0xbc, 0x49, 0xe8, 0x58, 0x76, 0x1c, 0xc7, 0xb1, 0x53, 0x59, 0xad, 0xed, 0x8d, 0x54, 0xb1,
	0xbd, 0x35, 0x2b, 0xe7, 0x78, 0xc1, 0x02, 0x67, 0x20, 0x0a, 0x11, 0x39, 0x98, 0x00, 0xa0, 0x56,
	0xdc, 0xab, 0xe4, 0x2a, 0x17, 0x79, 0x90, 0xf8, 0x01, 0xf2, 0x10, 0xb9, 0x70, 0x55, 0x1e, 0x21,
	0x55, 0x79, 0x92, 0x54, 0x03, 0x18, 0x0e, 0x45, 0xd1, 0x2b, 0xa6, 0x72, 0x37, 0xdd, 0xf8, 0xba,
	0xd1, 0xe8, 0x13, 0x7a, 0x00, 0xbd, 0x64, 0xa6, 0x8d, 0x9c, 0x72, 0x35, 0xc8, 0x95, 0x34, 0x92,
	0x06, 0x05, 0xdd, 0xff, 0x73, 0x15, 0xb6, 0x62, 0x9e, 0x4b, 0x65, 0x62, 0xfe, 0xc7, 0x19, 0xd7,
	0x86, 0xee, 0x41, 0x3b, 0x99, 0x08, 0x9e, 0x99, 0xa1, 0x48, 0xc3, 0xca, 0xfd, 0xca, 0x7e, 0x3b,
	0x0e, 0x1c, 0xe3, 0x28, 0xc5, 0xc5, 0x53, 0x25, 0xa7, 0xc3, 0x94, 0x19, 0x1e, 0x56, 0xdd, 0x22,
	0x32, 0x3e, 0x65, 0x86, 0xd3, 0x5d, 0x68, 0x19, 0xe9, 0x96, 0x6a, 0x76, 0xa9, 0x69, 0xa4, 0x5d,
	0xd8, 0x81, 0xe6, 0xa9, 0x54, 0x53, 0x66, 0xc2, 0xba, 0xe3, 0x3b, 0x8a, 0xfe, 0x1f, 0x74, 0x12,
	0x36, 0xcd, 0x99, 0x18, 0x67, 0xb8, 0x59, 0xc3, 0x2e, 0x42, 0xc1, 0x3a, 0x4a, 0xe9, 0x4b, 0x10,
	0x8c, 0x95, 0x9c, 0xe5, 0xc3, 0xd1, 0x3c, 0x6c, 0xdd, 0xaf, 0xed, 0xb7, 0xe3, 0x96, 0xa5, 0x0f,
	0xe7, 0xb8, 0x24, 0x55, 0xca, 0x15, 0x2e, 0x05, 0x6e, 0xc9, 0xd2, 0x87, 0x73, 0xba, 0x0f, 0x75,
	0x33, 0xcf, 0x79, 0xd8, 0xbe, 0x5f, 0xd9, 0xef, 0x1d, 0xdc, 0x1d, 0x2c, 0x0e, 0xef, 0x0e, 0x7a,
	0x32, 0xcf, 0x79, 0x6c, 0x11, 0xc7, 0xf5, 0xa0, 0x49, 0x5a, 0xfd, 0x37, 0xa0, 0x57, 0xb8, 0x40,
	0xe7, 0x32, 0xd3, 0x9c, 0x52, 0xa8, 0xa7, 0xcc, 0x30, 0x7f, 0x7c, 0xfb, 0xdd, 0x3f, 0x04, 0xf2,
	0x94, 0x9b, 0x47, 0x32, 0x3b, 0x15, 0xe3, 0xc2, 0x57, 0x03, 0x58, 0x78, 0xd2, 0x62, 0x3b, 0x07,
	0xb4, 0xdc, 0xed, 0x91, 0xff, 0x88, 0x4b, 0x6f, 0xff, 0x3f, 0xdc, 0x5e, 0xd2, 0xf1, 0x82, 0xcd,
	0x28, 0x90, 0xc7, 0x2b, 0x9b, 0xf5, 0x43, 0xd8, 0x79, 0xcc, 0xcd, 0xe1, 0x2c, 0x1d, 0x73, 0x13,
	0xf3, 0x29, 0x13, 0x59, 0xb1, 0xf2, 0x25, 0xec, 0x5e, 0x5b, 0xf1, 0xca, 0x5f, 0x18, 0xcd, 0x1d,
	0x68, 0x8e, 0xac, 0x90, 0x0d, 0x65, 0x35, 0xf6, 0x54, 0xff, 0xb7, 0x10, 0xa1, 0x99, 0x45, 0x1c,
	0x32, 0x96, 0x18, 0x71, 0xc1, 0x8b, 0x43, 0xaf, 0x44, 0xad, 0x72, 0x2d, 0x6a, 0x11, 0x04, 0xc2,
	0xcb, 0x58, 0xc5, 0x41, 0xbc, 0xa0, 0xfb, 0xbf, 0x83, 0xbd, 0xb5, 0xaa, 0xbd, 0xb9, 0xff, 0x93,
	0xee, 0xbf, 0x55, 0x20, 0x28, 0x9c, 0x4e, 0x3f, 0x83, 0x0e, 0x4b, 0x2f, 0xb8, 0x32, 0x42, 0x73,
	0xa5, 0xc3, 0xca, 0xfd, 0xda, 0x7e, 0xe7, 0xe0, 0xf5, 0xeb, 0xd1, 0x19, 0x3c, 0x2c, 0x51, 0x9f,
	0x65, 0x46, 0xcd, 0xe3, 0x65, 0xb9, 0xe8, 0x04, 0xc8, 0x2a, 0x80, 0x12, 0xa8, 0x9d, 0xf3, 0xb9,
	0x37, 0x0e, 0x3f, 0xe9, 0x03, 0x68, 0x5c, 0xb0, 0xc9, 0xcc, 0x99, 0xd4, 0x59, 0x4e, 0xb9, 0x52,
	0x38, 0x76, 0x90, 0x8f, 0xaa, 0x1f, 0x56, 0xfa, 0xff, 0xae, 0x02, 0x94, 0x2b, 0x98, 0x01, 0x19,
	0x9b, 0xf2, 0x22, 0x03, 0xf0, 0x9b, 0x3e, 0x84, 0x76, 0x71, 0x6c, 0x1d, 0x56, 0x57, 0xad, 0x2f,
	0x85, 0x07, 0x85, 0x2f, 0xbd, 0xf5, 0xa5, 0x94, 0x55, 0xa1, 0x38, 0x43, 0xdf, 0xe8, 0xb0, 0xf6,
	0x22, 0x15, 0x05, 0xaa, 0x50, 0x51, 0xd0, 0x98, 0x21, 0x6c, 0xcc, 0xb3, 0x64, 0x5e, 0x54, 0xae,
	0xa3, 0xa2, 0x27, 0xd0, 0xbb, 0xba, 0xef, 0x1a, 0xa7, 0xec, 0x5f, 0x75, 0xca, 0x72, 0x65, 0x78,
	0xd1, 0x25, 0x97, 0x58, 0x8d, 0x57, 0xcc, 0xf8, 0xef, 0x34, 0x7a, 0xd1, 0x65, 0x27, 0xff, 0xa3,
	0x01, 0x41, 0xb1, 0x13, 0xed, 0x41, 0x55, 0xa4, 0xbe, 0x63, 0x55, 0x45, 0x7a, 0xb5, 0x2e, 0x6a,
	0x2b, 0x75, 0xb1, 0x2e, 0x1e, 0x2f, 0x2f, 0x3b, 0xb3, 0x6e, 0x1b, 0xce, 0x92, 0x9f, 0x22, 0x08,
	0x12, 0x66, 0xf8, 0x58, 0xaa, 0x79, 0xd8, 0xb0, 0x8b, 0x0b, 0x9a, 0xbe, 0x0f, 0xad, 0x5c, 0x89,
	0x44, 0x64, 0xe3, 0xb0, 0x69, 0xed, 0x8e, 0xae, 0x7b, 0x62, 0xf0, 0xc4, 0x21, 0xe2, 0x02, 0x4a,
	0xdf, 0x5d, 0xd4, 0x66, 0xcb, 0x0a, 0xbd, 0xb4, 0x46, 0xc8, 0x57, 0xbc, 0x07, 0xd2, 0x77, 0xa1,
	0x6d, 0x98, 0x1a, 0x73, 0x83, 0x5b, 0x05, 0x56, 0xea, 0x4e, 0x29, 0x75, 0x52, 0x2c, 0xc5, 0x25,
	0x8a, 0xee, 0x03, 0x99, 0xb0, 0x2c, 0x15, 0xd9, 0x78, 0x98, 0xb3, 0x31, 0x1f, 0xce, 0xd4, 0x24,
	0x6c, 0x5b, 0xfb, 0x7b, 0x9e, 0xff, 0x84, 0x8d, 0xf9, 0xd7, 0x6a, 0x42, 0x3f, 0x80, 0x5d, 0x31,
	0xcd, 0x15, 0xd7, 0x5a, 0xc8, 0x6c, 0x68, 0x14, 0x4b, 0xce, 0x51, 0x0a, 0x05, 0xc0, 0xba, 0xe9,
	0x5e, 0xb9, 0x7c, 0xe2, 0x57, 0x51, 0x6e, 0xb9, 0x60, 0xb7, 0xae, 0x16, 0x2c, 0x7d, 0x1b, 0x88,
	0x33, 0x7d, 0x58, 0xda, 0xdd, 0xb3, 0x98, 0x6d, 0xc7, 0x5f, 0xd8, 0x4c, 0x5f, 0x01, 0xd0, 0x86,
	0x29, 0xe3, 0xae, 0x97, 0x6d, 0xbb, 0x63, 0xdb, 0x72, 0xec, 0x0d, 0xb3, 0x07, 0x6d, 0x6d, 0x64,
	0xee, 0x56, 0x89, 0x0b, 0x27, 0x32, 0xec, 0xe2, 0xeb, 0xb0, 0xa5, 0xb9, 0xba, 0x40, 0x73, 0xcf,
	0xe4, 0x4c, 0xe9, 0xf0, 0xf6, 0xfd, 0xda, 0x7e, 0x2d, 0xee, 0x7a, 0xe6, 0x2f, 0x90, 0x17, 0xfd,
	0x1a, 0x5a, 0x3e, 0x06, 0x36, 0x98, 0x33, 0xa5, 0x6c, 0xda, 0x17, 0x2d, 0xd3, 0xd3, 0x98, 0x94,
	0x23, 0x9f, 0x48, 0x95, 0x18, 0x3f, 0xe9, 0xab, 0x00, 0xe5, 0xc9, 0x6d, 0x2a, 0x55, 0xe2, 0x25,
	0x4e, 0xf4, 0x01, 0x34, 0x5d, 0x9c, 0xe8, 0x5d, 0x68, 0xa4, 0x4c, 0x4c, 0x9c, 0xd2, 0x4a, 0xec,
	0x08, 0x2c, 0x31, 0x3d, 0x95, 0xd2, 0x9c, 0xf9, 0x7e, 0xe6, 0xa9, 0xe3, 0x7a, 0xd0, 0x21, 0xdd,
	0xe3, 0x7a, 0xd0, 0x25, 0x5b, 0xfd, 0xbf, 0xd4, 0xa0, 0xf9, 0xa5, 0x4d, 0x35, 0x3a, 0x80, 0x26,
	0xd3, 0x9a, 0x9b, 0xa2, 0xa5, 0xed, 0x94, 0x11, 0x76, 0x88, 0xc1, 0x43, 0x5c, 0x8e, 0x3d, 0x2a,
	0xfa, 0xb6, 0x0a, 0x0d, 0xcb, 0xa1, 0x07, 0xd0, 0x30, 0xc2, 0x4c, 0xb8, 0xbf, 0xa9, 0x5e, 0x5e,
	0x2f, 0x38, 0x38, 0x41, 0x4c, 0xec, 0xa0, 0x28, 0x23, 0xa6, 0x6c, 0x5c, 0x54, 0xdc, 0x77, 0xc9,
	0x1c, 0x21, 0x26, 0x76, 0x50, 0xfa, 0x8e, 0xbf, 0xcf, 0x6a, 0x56, 0x64, 0xef, 0x3b, 0x44, 0x3e,
	0x65, 0x86, 0xb9, 0xcb, 0x2e, 0xda, 0x83, 0x86, 0xdd, 0x14, 0xeb, 0xce, 0xf0, 0x4b, 0x53, 0xd4,
	0x1d, 0x7e, 0x47, 0xbf, 0x87, 0x86, 0xd5, 0x8e, 0x9e, 0xc7, 0x64, 0xf3, 0xed, 0x60, 0xa6, 0x26,
	0xe8, 0xcf, 0x67, 0x22, 0xf5, 0x8e, 0xab, 0xc5, 0x8e, 0x40, 0x7f, 0x9e, 0x71, 0x31, 0x3e, 0x33,
	0xd6, 0x80, 0x5a, 0xec, 0x29, 0x54, 0x3e, 0x15, 0x53, 0xee, 0x1b, 0x99, 0xfd, 0x8e, 0x7e, 0x08,
	0x75, 0xb4, 0x03, 0x35, 0xb9, 0xc6, 0xe2, 0xb4, 0x3b, 0xc2, 0x9a, 0x83, 0x73, 0x84, 0x53, 0x6f,
	0xbf, 0xfb, 0x7f, 0x6f, 0x42, 0x50, 0x34, 0x9b, 0xb5, 0x7d, 0x62, 0xb5, 0xd1, 0xdc, 0x81, 0x06,
	0x4b, 0xcb, 0x26, 0x53, 0x67, 0x69, 0x71, 0x8b, 0x69, 0x9e, 0xcc, 0x94, 0xb3, 0xc7, 0x16, 0x85,
	0xa3, 0xe9, 0x03, 0xbf, 0x6b, 0xc3, 0x4e, 0x2f, 0x3b, 0xd7, 0x7b, 0x5c, 0x39, 0xbf, 0xf8, 0x2e,
	0x96, 0x9c, 0xdb, 0x32, 0x6c, 0x2e, 0xba, 0x58, 0x72, 0x8e, 0x95, 0xf7, 0x3d, 0xa8, 0x6b, 0xf1,
	0x9c, 0xfb, 0xfe, 0xb1, 0x7b, 0x5d, 0xd1, 0xe0, 0xa9, 0x78, 0xce, 0x63, 0x0b, 0xa2, 0xaf, 0x41,
	0xf7, 0xcc, 0x4c, 0x27, 0xc3, 0x44, 0x66, 0x86, 0x67, 0xc6, 0xb6, 0x8f, 0x76, 0xdc, 0x41, 0xde,
	0x23, 0xc7, 0x42, 0x27, 0xa1, 0xd3, 0x74, 0x08, 0xb6, 0x41, 0x38, 0x82, 0xee, 0x43, 0x33, 0x63,
	0x8b, 0xea, 0xee, 0x1c, 0x90, 0xd5, 0x78, 0xc7, 0x7e, 0x1d, 0x0b, 0x85, 0x19, 0xa3, 0xc4, 0x68,
	0x66, 0xb8, 0x0e, 0x7b, 0xb6, 0x06, 0x97, 0x38, 0x68, 0x82, 0x3b, 0xcc, 0x94, 0x25, 0x4a, 0x6a,
	0x5f, 0xc6, 0x1d, 0xcb, 0xfb, 0xc2, 0xb2, 0xb0, 0x5d, 0x2d, 0x43, 0x86, 0x5c, 0x27, 0xe1, 0x6d,
	0x0b, 0xeb, 0x2d, 0xc1, 0x3e, 0xd3, 0x09, 0x1d, 0x40, 0xe3, 0x42, 0xa4, 0x5c, 0x86, 0xd4, 0x5a,
	0x15, 0xae, 0x39, 0xfd, 0xaf, 0x70, 0x3d, 0x76, 0x30, 0xf4, 0xa4, 0x3d, 0xbf, 0x61, 0x63, 0x1d,
	0xde, 0xb1, 0xb6, 0x05, 0xc8, 0x38, 0x61, 0x63, 0x5d, 0xa4, 0xde, 0xdd, 0x45, 0xea, 0x45, 0xef,
	0x43, 0x1d, 0x9d, 0x57, 0xa6, 0x60, 0x65, 0x7d, 0x0a, 0x56, 0x97, 0x53, 0x30, 0xfa, 0x57, 0x05,
	0x1a, 0x76, 0x57, 0x4c, 0x80, 0x74, 0xa6, 0x98, 0xc1, 0x96, 0xe1, 0x44, 0x17, 0x34, 0xde, 0x34,
	0x76, 0x4a, 0x4f, 0xe4, 0xc4, 0xdd, 0xfc, 0xb5, 0xb8, 0x64, 0xe0, 0xdc, 0x7b, 0xc1, 0xb4, 0xb1,
	0x11, 0x77, 0x29, 0xd5, 0x42, 0x1a, 0x03, 0xfe, 0x2a, 0x80, 0x3e, 0x17, 0xb9, 0x3c, 0x3d, 0xd5,
	0xdc, 0x8d, 0xda, 0xb5, 0x78, 0x89, 0x43, 0xdf, 0x83, 0xc6, 0xa9, 0x98, 0x70, 0x6d, 0x6f, 0xa8,
	0xce, 0xc1, 0x2b, 0xdf, 0xe5, 0x93, 0xc1, 0xe7, 0x02, 0x3b, 0x80, 0xc5, 0x46, 0xdf, 0x87, 0x3a,
	0x92, 0x8b, 0xf2, 0xa9, 0x94, 0xe5, 0x53, 0xf8, 0xa5, 0xba, 0xf0, 0xcb, 0x71, 0x3d, 0x68, 0x13,
	0x58, 0x6e, 0x5d, 0xc7, 0xf5, 0x60, 0x9b, 0x90, 0xfe, 0xb7, 0x04, 0xda, 0x65, 0x33, 0x7f, 0x1b,
	0x6a, 0x63, 0x2e, 0x7d, 0x1f, 0xda, 0x5d, 0x73, 0x45, 0x0d, 0x1e, 0x73, 0x19, 0x23, 0x86, 0xbe,
	0x05, 0x55, 0x59, 0xcc, 0x3f, 0x3b, 0xeb, 0x90, 0x5f, 0x3d, 0x8d, 0xab, 0x52, 0xa3, 0xd3, 0x4e,
	0x15, 0x0e, 0xa8, 0xd8, 0xb4, 0x5d, 0xe1, 0x97, 0x0c, 0xfa, 0x63, 0x68, 0x25, 0x4c, 0x29, 0xc1,
	0x95, 0x2d, 0xab, 0x2b, 0x67, 0x2f, 0x55, 0xfd, 0x52, 0x68, 0xf3, 0x05, 0x33, 0xc9, 0x59, 0x5c,
	0xa0, 0xe9, 0x4f, 0x96, 0xee, 0xf5, 0xe6, 0x26, 0x92, 0xe5, 0xb5, 0xff, 0x33, 0xe8, 0xa4, 0xfc,
	0x42, 0x24, 0x7c, 0x68, 0xcb, 0xb9, 0xb5, 0x89, 0x34, 0x38, 0x09, 0xac, 0x70, 0xfa, 0x23, 0x68,
	0xa6, 0x12, 0x67, 0x79, 0x7f, 0x95, 0xdf, 0x20, 0xea, 0xc1, 0xf4, 0xa7, 0xd0, 0xce, 0x67, 0xa3,
	0x89, 0xd0, 0x67, 0x5c, 0xd9, 0x3f, 0xa0, 0x1b, 0x25, 0x4b, 0x3c, 0x7d, 0x07, 0x6a, 0x5a, 0xe7,
	0xf6, 0x42, 0xbf, 0x51, 0x0c, 0x91, 0xf4, 0x00, 0x9a, 0x63, 0x29, 0xc7, 0x13, 0x1e, 0x76, 0x56,
	0x47, 0x9b, 0xa5, 0x60, 0x5a, 0x44, 0xec, 0x91, 0x18, 0x8c, 0x8c, 0x9b, 0x67, 0x52, 0x9d, 0x87,
	0xdd, 0x8d, 0x82, 0xe1, 0xd1, 0x98, 0xfa, 0x8a, 0x65, 0x63, 0x3e, 0x14, 0xb9, 0x6d, 0x1f, 0xed,
	0xb8, 0x65, 0xe9, 0xa3, 0x9c, 0xfe, 0x1c, 0xba, 0x33, 0xe5, 0xba, 0x17, 0x13, 0x99, 0xb6, 0x03,
	0xc2, 0x8d, 0x8a, 0x3b, 0x33, 0x65, 0x9b, 0x1b, 0x4a, 0xd0, 0x0f, 0xa0, 0xa5, 0x85, 0xe1, 0xd8,
	0xa9, 0xc9, 0x46, 0xfe, 0x46, 0xf4, 0x51, 0x4a, 0xdf, 0x87, 0x26, 0xcb, 0x73, 0x14, 0xbb, 0xbd,
	0x89, 0x58, 0x83, 0xe5, 0xf9, 0x51, 0x4a, 0x3f, 0x06, 0x40, 0xa9, 0xd1, 0x2c, 0x4b, 0x27, 0xdc,
	0xf7, 0xa8, 0x9b, 0xc2, 0xc4, 0xf2, 0xfc, 0xd0, 0xe2, 0xe9, 0x53, 0xd8, 0xf1, 0xa9, 0x95, 0xc8,
	0x2c, 0xe3, 0x89, 0xb1, 0x23, 0x19, 0x66, 0xd9, 0x9d, 0x4d, 0x34, 0xdd, 0x75, 0xc2, 0x8f, 0x16,
	0xb2, 0x36, 0xdf, 0x3e, 0x85, 0x9e, 0xc8, 0x2e, 0x78, 0x66, 0xa4, 0x9a, 0x3b, 0x65, 0x77, 0x37,
	0x51, 0xb6, 0xb5, 0x10, 0xb2, 0x5a, 0xde, 0x82, 0x6d, 0x07, 0x1f, 0x8a, 0x7c, 0x68, 0xa3, 0x13,
	0xde, 0xb3, 0x17, 0xdc, 0x96, 0x63, 0x1f, 0xe5, 0x31, 0x32, 0xe9, 0x9b, 0xd0, 0xf3, 0x61, 0x1d,
	0xe6, 0x8a, 0x9f, 0x8a, 0xcb, 0x70, 0xc7, 0x46, 0x74, 0xcb, 0x73, 0x9f, 0x58, 0x26, 0xe6, 0xca,
	0x48, 0xc9, 0x67, 0x9a, 0xab, 0x70, 0x77, 0xa3, 0x5c, 0xf1, 0x68, 0x1c, 0x93, 0xc6, 0x5c, 0x62,
	0xa6, 0x84, 0x2f, 0xee, 0x32, 0x8d, 0x31, 0x97, 0x47, 0x39, 0x16, 0xba, 0xe2, 0xa7, 0x5c, 0x29,
	0xae, 0xc2, 0x97, 0x36, 0x2a, 0xf4, 0x02, 0x4e, 0x77, 0xa1, 0xc5, 0x52, 0x3d, 0x34, 0x97, 0x26,
	0x8c, 0xdc, 0x04, 0xc7, 0x52, 0x7d, 0x72, 0x69, 0x30, 0x5f, 0x17, 0x4e, 0xd8, 0x73, 0xad, 0x5a,
	0xf8, 0xe3, 0x7f, 0x0c, 0x30, 0xd3, 0x5c, 0x0d, 0xf1, 0x77, 0xca, 0x84, 0x2f, 0xaf, 0xf6, 0xe3,
	0x72, 0xc3, 0xaf, 0x35, 0x57, 0x0f, 0x11, 0x14, 0xb7, 0x67, 0xc5, 0x27, 0x4a, 0x8f, 0x58, 0x96,
	0x71, 0x35, 0xcc, 0xa5, 0x0e, 0x5f, 0xd9, 0x28, 0x7b, 0x9c, 0xc0, 0x13, 0xa9, 0xa3, 0x1f, 0x40,
	0xd3, 0x55, 0x24, 0x0e, 0xd5, 0x23, 0x31, 0x99, 0xe0, 0x60, 0x6c, 0x67, 0x16, 0xfb, 0x53, 0xe3,
	0x39, 0x47, 0xe9, 0x71, 0x3d, 0xa8, 0x90, 0x6a, 0xf4, 0x4d, 0x05, 0x6a, 0x8f, 0xb9, 0xb4, 0x3d,
	0x54, 0xce, 0xf0, 0xcf, 0xcc, 0x37, 0xee, 0x1b, 0x7b, 0xa8, 0x43, 0xd3, 0x77, 0xa1, 0x9e, 0x08,
	0x33, 0xf7, 0x23, 0xe4, 0x0d, 0x52, 0x16, 0x8a, 0xbd, 0x4f, 0xf1, 0x71, 0x31, 0x4f, 0xdf, 0x5c,
	0x8b, 0x0e, 0x1c, 0x1d, 0x40, 0xf5, 0xab, 0xa7, 0x6b, 0xa7, 0xb2, 0x10, 0x5a, 0x17, 0x5c, 0xd9,
	0x09, 0xbd, 0xea, 0x2f, 0x4d, 0x47, 0x46, 0x5f, 0x43, 0x7b, 0xa1, 0x08, 0x61, 0x22, 0x4b, 0x26,
	0xb3, 0xd4, 0x49, 0x07, 0x71, 0x41, 0xa2, 0xd2, 0x89, 0xd0, 0xc6, 0x3b, 0xc9, 0x7e, 0xe3, 0x25,
	0x8e, 0x37, 0x8c, 0x50, 0xdc, 0x4d, 0x77, 0x41, 0xbc, 0xa0, 0xa3, 0x7f, 0x56, 0xa1, 0xbd, 0x88,
	0x1d, 0xd6, 0x96, 0x4f, 0xcc, 0xe1, 0x29, 0x9b, 0x16, 0xbf, 0x00, 0x37, 0xd7, 0x96, 0x17, 0xfa,
	0xdc, 0xca, 0xd0, 0x43, 0x28, 0x18, 0xc3, 0x29, 0xfb, 0x83, 0x54, 0x9b, 0x79, 0xb4, 0xeb, 0x65,
	0xbe, 0x40, 0x11, 0xfa, 0x11, 0xb4, 0xa5, 0x2e, 0x8c, 0xd8, 0xc8, 0xb9, 0x81, 0xd4, 0x7e, 0xff,
	0x0f, 0x21, 0x90, 0xda, 0x6f, 0x5d, 0xdf, 0x28, 0x05, 0xa4, 0x76, 0xbb, 0x1e, 0xc2, 0x96, 0x6f,
	0x58, 0x7e, 0xe7, 0x8d, 0x6e, 0xe1, 0xae, 0x93, 0x71, 0xbb, 0x1f, 0xd7, 0x83, 0x3a, 0x69, 0x1c,
	0xd7, 0x83, 0x2d, 0xd2, 0x7b, 0xf0, 0x26, 0x40, 0xf9, 0x96, 0x47, 0xdb, 0xd0, 0x18, 0x31, 0x2d,
	0x12, 0x72, 0x8b, 0x76, 0x21, 0x60, 0xe9, 0x05, 0xcb, 0x12, 0x9e, 0x92, 0xca, 0x83, 0x3f, 0x55,
	0xa0, 0xbb, 0x3c, 0x35, 0xd3, 0x1d, 0xa0, 0xe6, 0x4c, 0xa8, 0x74, 0x98, 0x33, 0x65, 0xe6, 0x43,
	0x57, 0x13, 0xe4, 0x16, 0xbd, 0x07, 0xb7, 0x97, 0xf9, 0x76, 0x24, 0x24, 0x15, 0x0a, 0xc5, 0x6c,
	0x4b, 0xaa, 0xf8, 0xed, 0xe1, 0x35, 0x4a, 0xa0, 0x2b, 0x32, 0xc3, 0x95, 0x36, 0xc2, 0x08, 0x36,
	0x21, 0x75, 0x34, 0xc1, 0x09, 0x35, 0xd0, 0x84, 0x5c, 0xe6, 0xb3, 0x2c, 0xe5, 0x8a, 0x34, 0x1f,
	0x7c, 0x53, 0x85, 0xd6, 0x97, 0xfe, 0xfe, 0xda, 0x82, 0xf6, 0x48, 0xa4, 0xfa, 0x99, 0x30, 0xc9,
	0x19, 0xb9, 0x85, 0x1a, 0xdd, 0x8d, 0x48, 0x2a, 0x34, 0xc0, 0xe9, 0x4a, 0x69, 0x52, 0xf5, 0x27,
	0x98, 0xb2, 0x73, 0xbb, 0x53, 0x17, 0x02, 0x3d, 0x65, 0xca, 0x28, 0x33, 0x22, 0x75, 0xda, 0x82,
	0x9a, 0x34, 0x53, 0xd2, 0x40, 0x4d, 0x96, 0x3d, 0x67, 0xa9, 0x26, 0x4d, 0xd4, 0x74, 0xc9, 0x72,
	0xfc, 0x6e, 0x59, 0xf9, 0x3c, 0x97, 0x29, 0x67, 0x13, 0x12, 0x20, 0x30, 0x17, 0x97, 0xa7, 0x33,
	0x33, 0x53, 0x9c, 0xb4, 0x9d, 0x05, 0xcf, 0x9f, 0xdb, 0x59, 0x99, 0x00, 0xed, 0x40, 0x4b, 0x1b,
	0x25, 0x39, 0x57, 0xa4, 0x43, 0xb7, 0xa1, 0x83, 0xd6, 0x5d, 0x26, 0x67, 0xd8, 0xa1, 0x48, 0xd7,
	0x59, 0x72, 0xce, 0x55, 0xc6, 0x27, 0x64, 0xcb, 0x5a, 0xc8, 0x94, 0x26, 0x3d, 0x94, 0x62, 0xa9,
	0x39, 0x13, 0xd9, 0x39, 0xd9, 0xc6, 0xad, 0x2f, 0xb8, 0x32, 0xf2, 0x39, 0x21, 0x68, 0x1e, 0x93,
	0x13, 0x72, 0x1b, 0x11, 0x23, 0x6e, 0x9e, 0x71, 0x9e, 0x11, 0x8a, 0x84, 0xdd, 0xcf, 0xcc, 0xc9,
	0x1d, 0xab, 0x53, 0x19, 0xce, 0x47, 0x9c, 0x93, 0xbb, 0x48, 0x3d, 0xe7, 0x4a, 0xe6, 0x4c, 0x9d,
	0x93, 0x7b, 0x07, 0x7f, 0xad, 0x41, 0xed, 0xe1, 0x93, 0x23, 0xfa, 0x09, 0x34, 0x5d, 0x70, 0xe9,
	0xee, 0xea, 0xd3, 0xad, 0x7f, 0x82, 0x8c, 0xc2, 0xeb, 0x0b, 0xee, 0x01, 0xb1, 0x7f, 0x8b, 0x7e,
	0x0e, 0xed, 0xc5, 0x1b, 0x2b, 0x5d, 0x9a, 0x47, 0x56, 0x1f, 0x6f, 0xa3, 0xbd, 0xb5, 0x6b, 0x0b,
	0x3d, 0x9f, 0x40, 0xfb, 0xf1, 0x3a, 0x3d, 0xab, 0xef, 0xb2, 0xd1, 0x9a, 0x27, 0xdf, 0xfe, 0x2d,
	0x9a, 0xc2, 0x9d, 0x35, 0x0f, 0x9d, 0xf4, 0x8d, 0xab, 0x9b, 0xae, 0x7f, 0x62, 0x8d, 0xde, 0xbc,
	0x01, 0xb5, 0x30, 0xf2, 0x37, 0xb0, 0xbd, 0xf2, 0xf2, 0x4b, 0xef, 0x5f, 0x31, 0x75, 0xcd, 0x73,
	0x71, 0xf4, 0xda, 0x0b, 0x10, 0x85, 0xe6, 0x51, 0xd3, 0xfe, 0x72, 0xbc, 0xf7, 0x9f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x41, 0xa9, 0xb3, 0xf5, 0x3b, 0x18, 0x00, 0x00,
}
