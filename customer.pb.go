// Code generated by protoc-gen-go.
// source: customer/customer.proto
// DO NOT EDIT!

/*
Package customer is a generated protocol buffer package.

It is generated from these files:
	customer/customer.proto

It has these top-level messages:
	ReportRequest
	ReportResponse
	SetConfigRequest
	SetConfigResponse
	GetConfigRequest
	ConfigHistoryItem
	Customer
	Advertiser
	Campaign
	Native
	Creative
	Targeting
*/
package customer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CreativeType int32

const (
	CreativeType_third_party_banner CreativeType = 0
	CreativeType_third_party_video  CreativeType = 1
	CreativeType_native             CreativeType = 2
	CreativeType_banner             CreativeType = 3
	CreativeType_interstitial       CreativeType = 4
	CreativeType_video              CreativeType = 5
)

var CreativeType_name = map[int32]string{
	0: "third_party_banner",
	1: "third_party_video",
	2: "native",
	3: "banner",
	4: "interstitial",
	5: "video",
}
var CreativeType_value = map[string]int32{
	"third_party_banner": 0,
	"third_party_video":  1,
	"native":             2,
	"banner":             3,
	"interstitial":       4,
	"video":              5,
}

func (x CreativeType) String() string {
	return proto.EnumName(CreativeType_name, int32(x))
}
func (CreativeType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Network int32

const (
	Network_bidswitch Network = 0
	Network_google    Network = 1
	Network_mirs      Network = 2
	Network_advmaker  Network = 3
	Network_smartrtb  Network = 4
	Network_otm       Network = 5
)

var Network_name = map[int32]string{
	0: "bidswitch",
	1: "google",
	2: "mirs",
	3: "advmaker",
	4: "smartrtb",
	5: "otm",
}
var Network_value = map[string]int32{
	"bidswitch": 0,
	"google":    1,
	"mirs":      2,
	"advmaker":  3,
	"smartrtb":  4,
	"otm":       5,
}

func (x Network) String() string {
	return proto.EnumName(Network_name, int32(x))
}
func (Network) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type ReportRequest struct {
	ClientId string `protobuf:"bytes,1,opt,name=client_id,json=clientId" json:"client_id,omitempty"`
	// From date in the 'YYYY-MM-DD' format
	FromDate string `protobuf:"bytes,2,opt,name=from_date,json=fromDate" json:"from_date,omitempty"`
	// To date in the 'YYYY-MM-DD' format
	ToDate string `protobuf:"bytes,3,opt,name=to_date,json=toDate" json:"to_date,omitempty"`
	// Available output formats: Pretty, JSON, CSV[WithNames], TabSeparated[WithNames[AndTypes]], XML (default "Pretty")
	Format string `protobuf:"bytes,4,opt,name=format" json:"format,omitempty"`
}

func (m *ReportRequest) Reset()                    { *m = ReportRequest{} }
func (m *ReportRequest) String() string            { return proto.CompactTextString(m) }
func (*ReportRequest) ProtoMessage()               {}
func (*ReportRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ReportRequest) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *ReportRequest) GetFromDate() string {
	if m != nil {
		return m.FromDate
	}
	return ""
}

func (m *ReportRequest) GetToDate() string {
	if m != nil {
		return m.ToDate
	}
	return ""
}

func (m *ReportRequest) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

type ReportResponse struct {
	Data string `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *ReportResponse) Reset()                    { *m = ReportResponse{} }
func (m *ReportResponse) String() string            { return proto.CompactTextString(m) }
func (*ReportResponse) ProtoMessage()               {}
func (*ReportResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ReportResponse) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type SetConfigRequest struct {
	Customer *Customer `protobuf:"bytes,1,opt,name=customer" json:"customer,omitempty"`
}

func (m *SetConfigRequest) Reset()                    { *m = SetConfigRequest{} }
func (m *SetConfigRequest) String() string            { return proto.CompactTextString(m) }
func (*SetConfigRequest) ProtoMessage()               {}
func (*SetConfigRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SetConfigRequest) GetCustomer() *Customer {
	if m != nil {
		return m.Customer
	}
	return nil
}

type SetConfigResponse struct {
	Data string `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *SetConfigResponse) Reset()                    { *m = SetConfigResponse{} }
func (m *SetConfigResponse) String() string            { return proto.CompactTextString(m) }
func (*SetConfigResponse) ProtoMessage()               {}
func (*SetConfigResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SetConfigResponse) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type GetConfigRequest struct {
}

func (m *GetConfigRequest) Reset()                    { *m = GetConfigRequest{} }
func (m *GetConfigRequest) String() string            { return proto.CompactTextString(m) }
func (*GetConfigRequest) ProtoMessage()               {}
func (*GetConfigRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type ConfigHistoryItem struct {
	Id     string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Date   string `protobuf:"bytes,2,opt,name=date" json:"date,omitempty"`
	Diff   string `protobuf:"bytes,3,opt,name=diff" json:"diff,omitempty"`
	Author string `protobuf:"bytes,4,opt,name=author" json:"author,omitempty"`
}

func (m *ConfigHistoryItem) Reset()                    { *m = ConfigHistoryItem{} }
func (m *ConfigHistoryItem) String() string            { return proto.CompactTextString(m) }
func (*ConfigHistoryItem) ProtoMessage()               {}
func (*ConfigHistoryItem) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ConfigHistoryItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ConfigHistoryItem) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

func (m *ConfigHistoryItem) GetDiff() string {
	if m != nil {
		return m.Diff
	}
	return ""
}

func (m *ConfigHistoryItem) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

type Customer struct {
	// There should be at least one advertiser in the config.
	Advertisers map[string]*Advertiser `protobuf:"bytes,1,rep,name=advertisers" json:"advertisers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Customer) Reset()                    { *m = Customer{} }
func (m *Customer) String() string            { return proto.CompactTextString(m) }
func (*Customer) ProtoMessage()               {}
func (*Customer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Customer) GetAdvertisers() map[string]*Advertiser {
	if m != nil {
		return m.Advertisers
	}
	return nil
}

type Advertiser struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// There should be at least one campaign for each advertiser.
	Campaigns map[string]*Campaign `protobuf:"bytes,2,rep,name=campaigns" json:"campaigns,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// There should be at least one creative for each advertiser.
	Creatives map[string]*Creative `protobuf:"bytes,3,rep,name=creatives" json:"creatives,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Advertiser) Reset()                    { *m = Advertiser{} }
func (m *Advertiser) String() string            { return proto.CompactTextString(m) }
func (*Advertiser) ProtoMessage()               {}
func (*Advertiser) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Advertiser) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Advertiser) GetCampaigns() map[string]*Campaign {
	if m != nil {
		return m.Campaigns
	}
	return nil
}

func (m *Advertiser) GetCreatives() map[string]*Creative {
	if m != nil {
		return m.Creatives
	}
	return nil
}

type Campaign struct {
	// System extention fields. Do not Edit.
	Id        string   `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	ClientId  string   `protobuf:"bytes,3,opt,name=client_id,json=clientId" json:"client_id,omitempty"`
	Name      string   `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Creatives []string `protobuf:"bytes,4,rep,name=creatives" json:"creatives,omitempty"`
	// IAB content categories of the campaign. Refer to List 5.1 in the openRTB spec.
	// This is sent in the bid response as the "cat" field.
	// This is compared with the "bcat" field in the bid request. If matched - the campaign is not bidded.
	Category []string          `protobuf:"bytes,5,rep,name=category" json:"category,omitempty"`
	Pricing  *Campaign_Pricing `protobuf:"bytes,6,opt,name=pricing" json:"pricing,omitempty"`
	Budget   *Campaign_Budget  `protobuf:"bytes,7,opt,name=budget" json:"budget,omitempty"`
	// Required. If campaign has no targetings, please pass the empty object like {}.
	Targeting *Targeting `protobuf:"bytes,8,opt,name=targeting" json:"targeting,omitempty"`
	// URL of the landing page without get parameters.
	// This is sent to the "adomain" bid response field.
	// The landing page's domain is compared with the "badv" field in the bid request. If matched - the campaign is not bidded.
	LandingPageUrl []string `protobuf:"bytes,9,rep,name=landing_page_url,json=landingPageUrl" json:"landing_page_url,omitempty"`
	// The URL which will be called on the impression.
	// {RANDOM} macro could be used for cachebusting.
	// Note: if the impression tracker doesn't have the valid SSL certificate - please populate the "creative.insecure" flag to TRUE to avoid the stats discrepancies
	// Note: if the campaign has at least one creative with the "insecure" flag populated - this URL should has the "http://" protocol.
	ImpressionTrackingUrl string `protobuf:"bytes,10,opt,name=impression_tracking_url,json=impressionTrackingUrl" json:"impression_tracking_url,omitempty"`
	// Campaign start datetime in the YYYY-MM-DDThh:mm:ss±hh:mm format.
	// The date could be ommited (Thh:mm:ss±hh:mm format). In that case campaign is started daily at this time.
	StartDate string `protobuf:"bytes,11,opt,name=start_date,json=startDate" json:"start_date,omitempty"`
	// Campaign stop datetime in the YYYY-MM-DDThh:mm:ss±hh:mm format.
	// The date could be ommited (Thh:mm:ss±hh:mm format). In that case campaign is stopped daily at this time.
	StopDate string `protobuf:"bytes,12,opt,name=stop_date,json=stopDate" json:"stop_date,omitempty"`
	// Please populate this flag to TRUE if you need to pause the campaign without deleting it from the config.
	Inactive bool `protobuf:"varint,13,opt,name=inactive" json:"inactive,omitempty"`
}

func (m *Campaign) Reset()                    { *m = Campaign{} }
func (m *Campaign) String() string            { return proto.CompactTextString(m) }
func (*Campaign) ProtoMessage()               {}
func (*Campaign) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Campaign) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Campaign) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *Campaign) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Campaign) GetCreatives() []string {
	if m != nil {
		return m.Creatives
	}
	return nil
}

func (m *Campaign) GetCategory() []string {
	if m != nil {
		return m.Category
	}
	return nil
}

func (m *Campaign) GetPricing() *Campaign_Pricing {
	if m != nil {
		return m.Pricing
	}
	return nil
}

func (m *Campaign) GetBudget() *Campaign_Budget {
	if m != nil {
		return m.Budget
	}
	return nil
}

func (m *Campaign) GetTargeting() *Targeting {
	if m != nil {
		return m.Targeting
	}
	return nil
}

func (m *Campaign) GetLandingPageUrl() []string {
	if m != nil {
		return m.LandingPageUrl
	}
	return nil
}

func (m *Campaign) GetImpressionTrackingUrl() string {
	if m != nil {
		return m.ImpressionTrackingUrl
	}
	return ""
}

func (m *Campaign) GetStartDate() string {
	if m != nil {
		return m.StartDate
	}
	return ""
}

func (m *Campaign) GetStopDate() string {
	if m != nil {
		return m.StopDate
	}
	return ""
}

func (m *Campaign) GetInactive() bool {
	if m != nil {
		return m.Inactive
	}
	return false
}

// Required
type Campaign_Pricing struct {
	// This is compared against ortb field "cur" from the bid request,
	// which contains ISO-4217 alpha codes of the currencies, allowed for the bid.
	Currency string `protobuf:"bytes,1,opt,name=currency" json:"currency,omitempty"`
	// This number is sent into the bid response as the bid CPM price.
	// This field is required and should be more then zero.
	Bid float64 `protobuf:"fixed64,2,opt,name=bid" json:"bid,omitempty"`
	// This number divided by 1,000 (CPM) the campaign budget is decreased on the impression.
	// This field is required and should be not less then pricing.bid
	Impression float64 `protobuf:"fixed64,3,opt,name=impression" json:"impression,omitempty"`
}

func (m *Campaign_Pricing) Reset()                    { *m = Campaign_Pricing{} }
func (m *Campaign_Pricing) String() string            { return proto.CompactTextString(m) }
func (*Campaign_Pricing) ProtoMessage()               {}
func (*Campaign_Pricing) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

func (m *Campaign_Pricing) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *Campaign_Pricing) GetBid() float64 {
	if m != nil {
		return m.Bid
	}
	return 0
}

func (m *Campaign_Pricing) GetImpression() float64 {
	if m != nil {
		return m.Impression
	}
	return 0
}

type Campaign_Budget struct {
	// Campaign daily budget limit. Daily budget is reseted every day at midnight by the UTC+3 (Moscow) time zone.
	// This field is required and should be more the zero.
	Daily float64 `protobuf:"fixed64,1,opt,name=daily" json:"daily,omitempty"`
}

func (m *Campaign_Budget) Reset()                    { *m = Campaign_Budget{} }
func (m *Campaign_Budget) String() string            { return proto.CompactTextString(m) }
func (*Campaign_Budget) ProtoMessage()               {}
func (*Campaign_Budget) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 1} }

func (m *Campaign_Budget) GetDaily() float64 {
	if m != nil {
		return m.Daily
	}
	return 0
}

type Native struct {
	Assets []*Native_Asset `protobuf:"bytes,1,rep,name=assets" json:"assets,omitempty"`
}

func (m *Native) Reset()                    { *m = Native{} }
func (m *Native) String() string            { return proto.CompactTextString(m) }
func (*Native) ProtoMessage()               {}
func (*Native) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Native) GetAssets() []*Native_Asset {
	if m != nil {
		return m.Assets
	}
	return nil
}

type Native_Asset struct {
	Title *Native_Asset_Title `protobuf:"bytes,1,opt,name=title" json:"title,omitempty"`
	Image *Native_Asset_Image `protobuf:"bytes,2,opt,name=image" json:"image,omitempty"`
	Data  *Native_Asset_Data  `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
}

func (m *Native_Asset) Reset()                    { *m = Native_Asset{} }
func (m *Native_Asset) String() string            { return proto.CompactTextString(m) }
func (*Native_Asset) ProtoMessage()               {}
func (*Native_Asset) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 0} }

func (m *Native_Asset) GetTitle() *Native_Asset_Title {
	if m != nil {
		return m.Title
	}
	return nil
}

func (m *Native_Asset) GetImage() *Native_Asset_Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *Native_Asset) GetData() *Native_Asset_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type Native_Asset_Title struct {
	Text string `protobuf:"bytes,1,opt,name=text" json:"text,omitempty"`
}

func (m *Native_Asset_Title) Reset()                    { *m = Native_Asset_Title{} }
func (m *Native_Asset_Title) String() string            { return proto.CompactTextString(m) }
func (*Native_Asset_Title) ProtoMessage()               {}
func (*Native_Asset_Title) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 0, 0} }

func (m *Native_Asset_Title) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type Native_Asset_Image struct {
	Url    string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	Width  int64  `protobuf:"varint,2,opt,name=width" json:"width,omitempty"`
	Height int64  `protobuf:"varint,3,opt,name=height" json:"height,omitempty"`
	Mime   string `protobuf:"bytes,4,opt,name=mime" json:"mime,omitempty"`
}

func (m *Native_Asset_Image) Reset()                    { *m = Native_Asset_Image{} }
func (m *Native_Asset_Image) String() string            { return proto.CompactTextString(m) }
func (*Native_Asset_Image) ProtoMessage()               {}
func (*Native_Asset_Image) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 0, 1} }

func (m *Native_Asset_Image) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Native_Asset_Image) GetWidth() int64 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Native_Asset_Image) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Native_Asset_Image) GetMime() string {
	if m != nil {
		return m.Mime
	}
	return ""
}

type Native_Asset_Data struct {
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
	Type  int64  `protobuf:"varint,2,opt,name=type" json:"type,omitempty"`
}

func (m *Native_Asset_Data) Reset()                    { *m = Native_Asset_Data{} }
func (m *Native_Asset_Data) String() string            { return proto.CompactTextString(m) }
func (*Native_Asset_Data) ProtoMessage()               {}
func (*Native_Asset_Data) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 0, 2} }

func (m *Native_Asset_Data) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Native_Asset_Data) GetType() int64 {
	if m != nil {
		return m.Type
	}
	return 0
}

type Creative struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Please ignore this field.
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// Please ignore this field.
	AdId string `protobuf:"bytes,3,opt,name=ad_id,json=adId" json:"ad_id,omitempty"`
	// Please populate this flag to TRUE in case the creative code has the "http://" requests
	// or impression_tracking_url doesn't have the valid SSL certificate.
	// Please note that some ad networks (google for example) require all the served content to be secured.
	// For those networks you will not receive bids for the creatives with the insecure flag populated.
	Insecure bool `protobuf:"varint,4,opt,name=insecure" json:"insecure,omitempty"`
	// Available creative types:
	// 0 or blank - "third_party_banner";
	// 1 - "third_party_video";
	// 2 - "native";
	// 4 - "interstitial";
	// 5 - "video".
	Type CreativeType `protobuf:"varint,5,opt,name=type,enum=customer.CreativeType" json:"type,omitempty"`
	// URL the user is sent to on click. Should contains the protocol (http:// or https://).
	// This is required for the creatives which should be rotated in the Google Ad Exchange.
	// If you use some ad server you might need to generate the click URL dynamic instead of populate it in the config.
	// For this just put the escaped vertion of the click URL in the "html_content" of the creative right after the click macro.
	// Valid example: {CLICK_URL}http%3A%2F%2Flanding-page.com
	// Invalid example: {CLICK_URL}http://landing-page.com
	ClickUrl string         `protobuf:"bytes,6,opt,name=click_url,json=clickUrl" json:"click_url,omitempty"`
	Size     *Creative_Size `protobuf:"bytes,7,opt,name=size" json:"size,omitempty"`
	// Creative's html snippet. Should contains valid html code.
	// This field could contains the following macros:
	// {CLICK_URL} will be resolved to the click URL handler.
	// {CLICK_URL_ESC} will be resolved to the escaped click URL handler.
	// {PUB_ID} will be resolved to the publisher id.
	// Note: either {CLICK_URL} or {CLICK_URL_ESC} is required for the creatives which should be rotated in the Google Ad Exchange.
	// This field size should not exceed 8Kb.
	HtmlContent string `protobuf:"bytes,8,opt,name=html_content,json=htmlContent" json:"html_content,omitempty"`
	// Video ad duration in seconds. Required for the creative type "video".
	// This is compared with the "video.minduration" and "video.maxduration" fields in the bid request.
	// Creative's duration should be between these values to be eligible for bid.
	Duration int64 `protobuf:"varint,9,opt,name=duration" json:"duration,omitempty"`
	// Creative's MIME type. This is compared with the "banner.mimes" field in the bid request.
	// If no matches - creative is not eligible for bid.
	Mimes []string `protobuf:"bytes,10,rep,name=mimes" json:"mimes,omitempty"`
	// Supported video protocols. Required for the creative type "video". Refer to List 5.8 in the Open RTB spec.
	// This is compared with the "video.protocols" field in the bid request.
	// If no matches - creative is not eligible for bid.
	Protocols []int64 `protobuf:"varint,11,rep,packed,name=protocols" json:"protocols,omitempty"`
	// The URL which returns the valid VAST XML.
	// Required for the creative type "video".
	VastUrl string  `protobuf:"bytes,12,opt,name=vast_url,json=vastUrl" json:"vast_url,omitempty"`
	Native  *Native `protobuf:"bytes,13,opt,name=native" json:"native,omitempty"`
	// IAB creative attributes. Refer to List 5.3 in the openRTB spec.
	// This is sent in the bid response in the "bid.attr" field.
	// This is compared with the "battr" field in the bid request. If matched - the creative is not bidded.
	Attributes []int64 `protobuf:"varint,14,rep,packed,name=attributes" json:"attributes,omitempty"`
	// Number of seconds before the SKIP button is appeared in the video ad.
	// Mandatory for the skippable video creatives.
	Skipoffset    int64  `protobuf:"varint,15,opt,name=skipoffset" json:"skipoffset,omitempty"`
	ClickMacro    string `protobuf:"bytes,16,opt,name=click_macro,json=clickMacro" json:"click_macro,omitempty"`
	ClickMacroEsc string `protobuf:"bytes,17,opt,name=click_macro_esc,json=clickMacroEsc" json:"click_macro_esc,omitempty"`
}

func (m *Creative) Reset()                    { *m = Creative{} }
func (m *Creative) String() string            { return proto.CompactTextString(m) }
func (*Creative) ProtoMessage()               {}
func (*Creative) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Creative) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Creative) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Creative) GetAdId() string {
	if m != nil {
		return m.AdId
	}
	return ""
}

func (m *Creative) GetInsecure() bool {
	if m != nil {
		return m.Insecure
	}
	return false
}

func (m *Creative) GetType() CreativeType {
	if m != nil {
		return m.Type
	}
	return CreativeType_third_party_banner
}

func (m *Creative) GetClickUrl() string {
	if m != nil {
		return m.ClickUrl
	}
	return ""
}

func (m *Creative) GetSize() *Creative_Size {
	if m != nil {
		return m.Size
	}
	return nil
}

func (m *Creative) GetHtmlContent() string {
	if m != nil {
		return m.HtmlContent
	}
	return ""
}

func (m *Creative) GetDuration() int64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Creative) GetMimes() []string {
	if m != nil {
		return m.Mimes
	}
	return nil
}

func (m *Creative) GetProtocols() []int64 {
	if m != nil {
		return m.Protocols
	}
	return nil
}

func (m *Creative) GetVastUrl() string {
	if m != nil {
		return m.VastUrl
	}
	return ""
}

func (m *Creative) GetNative() *Native {
	if m != nil {
		return m.Native
	}
	return nil
}

func (m *Creative) GetAttributes() []int64 {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Creative) GetSkipoffset() int64 {
	if m != nil {
		return m.Skipoffset
	}
	return 0
}

func (m *Creative) GetClickMacro() string {
	if m != nil {
		return m.ClickMacro
	}
	return ""
}

func (m *Creative) GetClickMacroEsc() string {
	if m != nil {
		return m.ClickMacroEsc
	}
	return ""
}

type Creative_Size struct {
	Width  int64 `protobuf:"varint,1,opt,name=width" json:"width,omitempty"`
	Height int64 `protobuf:"varint,2,opt,name=height" json:"height,omitempty"`
}

func (m *Creative_Size) Reset()                    { *m = Creative_Size{} }
func (m *Creative_Size) String() string            { return proto.CompactTextString(m) }
func (*Creative_Size) ProtoMessage()               {}
func (*Creative_Size) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 0} }

func (m *Creative_Size) GetWidth() int64 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Creative_Size) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type Targeting struct {
	Geo *Targeting_Geo  `protobuf:"bytes,1,opt,name=geo" json:"geo,omitempty"`
	Os  []*Targeting_OS `protobuf:"bytes,2,rep,name=os" json:"os,omitempty"`
	// The minimum delay between any two impressions for the single user in the one ad network in seconds.
	// Works by "user.id" field in the bid request.
	Frequency int64                `protobuf:"varint,3,opt,name=frequency" json:"frequency,omitempty"`
	UserAgent *Targeting_UserAgent `protobuf:"bytes,4,opt,name=user_agent,json=userAgent" json:"user_agent,omitempty"`
	// Carrier or ISP as it's declared in the "device.carrier" field in the bid request.
	// For Google Ad Exchange use the Criterion ID string from this list to target: https://developers.google.com/adwords/api/docs/appendix/mobilecarriers.csv
	Carrier *Targeting_ListMatch `protobuf:"bytes,5,opt,name=carrier" json:"carrier,omitempty"`
	// IAB content categories as it's declared in the "site.cat" or "app.cat" fields in the bid request.
	Cat *Targeting_ListMatch `protobuf:"bytes,6,opt,name=cat" json:"cat,omitempty"`
	// The general type of device as it's declared in the "device.devicetype" field in the bid request.
	// Refer to List 5.17 in the Open RTB spec.
	DeviceType *Targeting_ListMatch `protobuf:"bytes,7,opt,name=device_type,json=deviceType" json:"device_type,omitempty"`
	// Site's domain is extracted from the "site.page" field in the bid request and compared with the populated list.
	Domain *Targeting_ListMatch `protobuf:"bytes,8,opt,name=domain" json:"domain,omitempty"`
	// Works by the "publisher.id" field in the bid request.
	Publisher *Targeting_ListMatch `protobuf:"bytes,9,opt,name=publisher" json:"publisher,omitempty"`
	// Works by the "ext.ssp" field for the Bidswitch's request.
	// Works by the "ext.exchange" field for the SmartRTB's request.
	Ssp    *Targeting_ListMatch `protobuf:"bytes,10,opt,name=ssp" json:"ssp,omitempty"`
	Google *Targeting_Google    `protobuf:"bytes,11,opt,name=google" json:"google,omitempty"`
	// Connected ad networks targeting. Please ask your account manager to obtain the available networks list.
	Network *Targeting_ListMatch `protobuf:"bytes,12,opt,name=network" json:"network,omitempty"`
	// Works by the "device.ip" field in the bid request.
	Ip *Targeting_ListMatch `protobuf:"bytes,13,opt,name=ip" json:"ip,omitempty"`
	// Please use the "255.255.255.255/n" format for the ip ranges where "n" is the number of the first bits in the subnet mask.
	// For example "20.78.168.0/21" represents IPv4 addresses between "220.78.168.0" and "220.78.175.255"
	RangeIp []string `protobuf:"bytes,14,rep,name=range_ip,json=rangeIp" json:"range_ip,omitempty"`
	// This targeting search the substring into the "site.page" field of the bid request.
	// For example if you target to include the "news.ru/sport" string,
	// the site.page "http://www.news.ru/sports-and-hobbies/article.html" will pass
	// and the "http://www.news.ru/team-sport" will not.
	UrlContains *Targeting_ListMatch `protobuf:"bytes,15,opt,name=url_contains,json=urlContains" json:"url_contains,omitempty"`
	// Works by the "site.id" field in the bid request.
	SiteId *Targeting_ListMatch `protobuf:"bytes,16,opt,name=site_id,json=siteId" json:"site_id,omitempty"`
	// Works by the "app.id" field in the bid request.
	AppId *Targeting_ListMatch `protobuf:"bytes,17,opt,name=app_id,json=appId" json:"app_id,omitempty"`
}

func (m *Targeting) Reset()                    { *m = Targeting{} }
func (m *Targeting) String() string            { return proto.CompactTextString(m) }
func (*Targeting) ProtoMessage()               {}
func (*Targeting) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Targeting) GetGeo() *Targeting_Geo {
	if m != nil {
		return m.Geo
	}
	return nil
}

func (m *Targeting) GetOs() []*Targeting_OS {
	if m != nil {
		return m.Os
	}
	return nil
}

func (m *Targeting) GetFrequency() int64 {
	if m != nil {
		return m.Frequency
	}
	return 0
}

func (m *Targeting) GetUserAgent() *Targeting_UserAgent {
	if m != nil {
		return m.UserAgent
	}
	return nil
}

func (m *Targeting) GetCarrier() *Targeting_ListMatch {
	if m != nil {
		return m.Carrier
	}
	return nil
}

func (m *Targeting) GetCat() *Targeting_ListMatch {
	if m != nil {
		return m.Cat
	}
	return nil
}

func (m *Targeting) GetDeviceType() *Targeting_ListMatch {
	if m != nil {
		return m.DeviceType
	}
	return nil
}

func (m *Targeting) GetDomain() *Targeting_ListMatch {
	if m != nil {
		return m.Domain
	}
	return nil
}

func (m *Targeting) GetPublisher() *Targeting_ListMatch {
	if m != nil {
		return m.Publisher
	}
	return nil
}

func (m *Targeting) GetSsp() *Targeting_ListMatch {
	if m != nil {
		return m.Ssp
	}
	return nil
}

func (m *Targeting) GetGoogle() *Targeting_Google {
	if m != nil {
		return m.Google
	}
	return nil
}

func (m *Targeting) GetNetwork() *Targeting_ListMatch {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *Targeting) GetIp() *Targeting_ListMatch {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *Targeting) GetRangeIp() []string {
	if m != nil {
		return m.RangeIp
	}
	return nil
}

func (m *Targeting) GetUrlContains() *Targeting_ListMatch {
	if m != nil {
		return m.UrlContains
	}
	return nil
}

func (m *Targeting) GetSiteId() *Targeting_ListMatch {
	if m != nil {
		return m.SiteId
	}
	return nil
}

func (m *Targeting) GetAppId() *Targeting_ListMatch {
	if m != nil {
		return m.AppId
	}
	return nil
}

// Required for campaigns, which should be served in the Google Ad Exchange
type Targeting_Google struct {
	BillingId string `protobuf:"bytes,1,opt,name=billing_id,json=billingId" json:"billing_id,omitempty"`
}

func (m *Targeting_Google) Reset()                    { *m = Targeting_Google{} }
func (m *Targeting_Google) String() string            { return proto.CompactTextString(m) }
func (*Targeting_Google) ProtoMessage()               {}
func (*Targeting_Google) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 0} }

func (m *Targeting_Google) GetBillingId() string {
	if m != nil {
		return m.BillingId
	}
	return ""
}

type Targeting_Geo struct {
	// Country code using ISO-3166-1-alpha-3.
	// Works by the "device.geo.country" field in the bid request.
	Country *Targeting_ListMatch `protobuf:"bytes,1,opt,name=country" json:"country,omitempty"`
	// City using United Nations Code for Trade & Transport Locations: : http://www.unece.org/cefact/locode/service/location.html
	// Works by the "device.geo.city" field in the bid request.
	City *Targeting_ListMatch `protobuf:"bytes,2,opt,name=city" json:"city,omitempty"`
	// Region code using ISO-3166-2; 2-letter state code if USA.
	// Works by the "device.geo.region" field in the bid request.
	Region *Targeting_ListMatch `protobuf:"bytes,3,opt,name=region" json:"region,omitempty"`
}

func (m *Targeting_Geo) Reset()                    { *m = Targeting_Geo{} }
func (m *Targeting_Geo) String() string            { return proto.CompactTextString(m) }
func (*Targeting_Geo) ProtoMessage()               {}
func (*Targeting_Geo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 1} }

func (m *Targeting_Geo) GetCountry() *Targeting_ListMatch {
	if m != nil {
		return m.Country
	}
	return nil
}

func (m *Targeting_Geo) GetCity() *Targeting_ListMatch {
	if m != nil {
		return m.City
	}
	return nil
}

func (m *Targeting_Geo) GetRegion() *Targeting_ListMatch {
	if m != nil {
		return m.Region
	}
	return nil
}

type Targeting_OS struct {
	// Device operating system as it's declared in the "device.os" field in the bid request.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Device operating system version as it's declared in the "device.osv" field in the bid request.
	Version string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
}

func (m *Targeting_OS) Reset()                    { *m = Targeting_OS{} }
func (m *Targeting_OS) String() string            { return proto.CompactTextString(m) }
func (*Targeting_OS) ProtoMessage()               {}
func (*Targeting_OS) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 2} }

func (m *Targeting_OS) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Targeting_OS) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type Targeting_UserAgent struct {
	// Available browser names: "Opera", "Edge", "Chrome", "Safari", "Internet Explorer"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// If the flag is set to TRUE, the only mobile versions of the browser's user agent are passed.
	Mobile bool `protobuf:"varint,2,opt,name=mobile" json:"mobile,omitempty"`
}

func (m *Targeting_UserAgent) Reset()                    { *m = Targeting_UserAgent{} }
func (m *Targeting_UserAgent) String() string            { return proto.CompactTextString(m) }
func (*Targeting_UserAgent) ProtoMessage()               {}
func (*Targeting_UserAgent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 3} }

func (m *Targeting_UserAgent) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Targeting_UserAgent) GetMobile() bool {
	if m != nil {
		return m.Mobile
	}
	return false
}

type Targeting_ListMatch struct {
	Include bool     `protobuf:"varint,1,opt,name=include" json:"include,omitempty"`
	List    []string `protobuf:"bytes,2,rep,name=list" json:"list,omitempty"`
}

func (m *Targeting_ListMatch) Reset()                    { *m = Targeting_ListMatch{} }
func (m *Targeting_ListMatch) String() string            { return proto.CompactTextString(m) }
func (*Targeting_ListMatch) ProtoMessage()               {}
func (*Targeting_ListMatch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 4} }

func (m *Targeting_ListMatch) GetInclude() bool {
	if m != nil {
		return m.Include
	}
	return false
}

func (m *Targeting_ListMatch) GetList() []string {
	if m != nil {
		return m.List
	}
	return nil
}

func init() {
	proto.RegisterType((*ReportRequest)(nil), "customer.ReportRequest")
	proto.RegisterType((*ReportResponse)(nil), "customer.ReportResponse")
	proto.RegisterType((*SetConfigRequest)(nil), "customer.SetConfigRequest")
	proto.RegisterType((*SetConfigResponse)(nil), "customer.SetConfigResponse")
	proto.RegisterType((*GetConfigRequest)(nil), "customer.GetConfigRequest")
	proto.RegisterType((*ConfigHistoryItem)(nil), "customer.ConfigHistoryItem")
	proto.RegisterType((*Customer)(nil), "customer.Customer")
	proto.RegisterType((*Advertiser)(nil), "customer.Advertiser")
	proto.RegisterType((*Campaign)(nil), "customer.Campaign")
	proto.RegisterType((*Campaign_Pricing)(nil), "customer.Campaign.Pricing")
	proto.RegisterType((*Campaign_Budget)(nil), "customer.Campaign.Budget")
	proto.RegisterType((*Native)(nil), "customer.Native")
	proto.RegisterType((*Native_Asset)(nil), "customer.Native.Asset")
	proto.RegisterType((*Native_Asset_Title)(nil), "customer.Native.Asset.Title")
	proto.RegisterType((*Native_Asset_Image)(nil), "customer.Native.Asset.Image")
	proto.RegisterType((*Native_Asset_Data)(nil), "customer.Native.Asset.Data")
	proto.RegisterType((*Creative)(nil), "customer.Creative")
	proto.RegisterType((*Creative_Size)(nil), "customer.Creative.Size")
	proto.RegisterType((*Targeting)(nil), "customer.Targeting")
	proto.RegisterType((*Targeting_Google)(nil), "customer.Targeting.Google")
	proto.RegisterType((*Targeting_Geo)(nil), "customer.Targeting.Geo")
	proto.RegisterType((*Targeting_OS)(nil), "customer.Targeting.OS")
	proto.RegisterType((*Targeting_UserAgent)(nil), "customer.Targeting.UserAgent")
	proto.RegisterType((*Targeting_ListMatch)(nil), "customer.Targeting.ListMatch")
	proto.RegisterEnum("customer.CreativeType", CreativeType_name, CreativeType_value)
	proto.RegisterEnum("customer.Network", Network_name, Network_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for API service

type APIClient interface {
	// Return clients metricks for the specified client ID with breakdown by Campaign ID.
	Report(ctx context.Context, in *ReportRequest, opts ...grpc.CallOption) (*ReportResponse, error)
	SetConfig(ctx context.Context, in *SetConfigRequest, opts ...grpc.CallOption) (*SetConfigResponse, error)
	GetConfig(ctx context.Context, in *GetConfigRequest, opts ...grpc.CallOption) (*Customer, error)
}

type aPIClient struct {
	cc *grpc.ClientConn
}

func NewAPIClient(cc *grpc.ClientConn) APIClient {
	return &aPIClient{cc}
}

func (c *aPIClient) Report(ctx context.Context, in *ReportRequest, opts ...grpc.CallOption) (*ReportResponse, error) {
	out := new(ReportResponse)
	err := grpc.Invoke(ctx, "/customer.API/Report", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) SetConfig(ctx context.Context, in *SetConfigRequest, opts ...grpc.CallOption) (*SetConfigResponse, error) {
	out := new(SetConfigResponse)
	err := grpc.Invoke(ctx, "/customer.API/SetConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GetConfig(ctx context.Context, in *GetConfigRequest, opts ...grpc.CallOption) (*Customer, error) {
	out := new(Customer)
	err := grpc.Invoke(ctx, "/customer.API/GetConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for API service

type APIServer interface {
	// Return clients metricks for the specified client ID with breakdown by Campaign ID.
	Report(context.Context, *ReportRequest) (*ReportResponse, error)
	SetConfig(context.Context, *SetConfigRequest) (*SetConfigResponse, error)
	GetConfig(context.Context, *GetConfigRequest) (*Customer, error)
}

func RegisterAPIServer(s *grpc.Server, srv APIServer) {
	s.RegisterService(&_API_serviceDesc, srv)
}

func _API_Report_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).Report(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/customer.API/Report",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).Report(ctx, req.(*ReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_SetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).SetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/customer.API/SetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).SetConfig(ctx, req.(*SetConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/customer.API/GetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).GetConfig(ctx, req.(*GetConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _API_serviceDesc = grpc.ServiceDesc{
	ServiceName: "customer.API",
	HandlerType: (*APIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Report",
			Handler:    _API_Report_Handler,
		},
		{
			MethodName: "SetConfig",
			Handler:    _API_SetConfig_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _API_GetConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "customer/customer.proto",
}

func init() { proto.RegisterFile("customer/customer.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1675 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x57, 0xdb, 0x72, 0xdc, 0xc6,
	0x11, 0xd5, 0x02, 0x7b, 0x43, 0x2f, 0x45, 0x83, 0x63, 0x9b, 0x84, 0x41, 0xdb, 0x61, 0x36, 0x29,
	0x7b, 0xa3, 0x54, 0x56, 0x11, 0xa3, 0xd8, 0xb9, 0x39, 0x15, 0x5a, 0x56, 0x94, 0xad, 0x8a, 0x6d,
	0x15, 0x48, 0x57, 0x1e, 0xf2, 0xb0, 0x35, 0x0b, 0x0c, 0xb1, 0x53, 0x04, 0x30, 0xc8, 0xcc, 0x80,
	0xca, 0xea, 0x07, 0xf2, 0x29, 0xc9, 0xb7, 0x24, 0x7e, 0xcc, 0x67, 0xe4, 0x23, 0x52, 0x73, 0xc1,
	0x85, 0xab, 0x95, 0x57, 0x7e, 0x9b, 0xee, 0x3e, 0xdd, 0xd3, 0xd3, 0xd3, 0xa7, 0x07, 0x80, 0x93,
	0xb8, 0x12, 0x92, 0xe5, 0x84, 0x3f, 0xac, 0x17, 0xf3, 0x92, 0x33, 0xc9, 0xd0, 0xb8, 0x96, 0xa7,
	0x2f, 0xe1, 0x7e, 0x44, 0x4a, 0xc6, 0x65, 0x44, 0xfe, 0x56, 0x11, 0x21, 0xd1, 0x29, 0x78, 0x71,
	0x46, 0x49, 0x21, 0x97, 0x34, 0x09, 0x7a, 0x67, 0xbd, 0x99, 0x17, 0x8d, 0x8d, 0x62, 0x91, 0x28,
	0xe3, 0x35, 0x67, 0xf9, 0x32, 0xc1, 0x92, 0x04, 0x8e, 0x31, 0x2a, 0xc5, 0x17, 0x58, 0x12, 0x74,
	0x02, 0x23, 0xc9, 0x8c, 0xc9, 0xd5, 0xa6, 0xa1, 0x64, 0xda, 0x70, 0x0c, 0xc3, 0x6b, 0xc6, 0x73,
	0x2c, 0x83, 0xbe, 0xd1, 0x1b, 0x69, 0xfa, 0x63, 0x38, 0xac, 0xf7, 0x16, 0x25, 0x2b, 0x04, 0x41,
	0x08, 0xfa, 0x09, 0x96, 0xd8, 0xee, 0xab, 0xd7, 0xd3, 0xcf, 0xc1, 0xbf, 0x24, 0xf2, 0x09, 0x2b,
	0xae, 0x69, 0x5a, 0x27, 0x39, 0x87, 0xe6, 0x04, 0x1a, 0x3b, 0x39, 0x47, 0xf3, 0xe6, 0x88, 0x4f,
	0xec, 0x22, 0x6a, 0x4f, 0xf9, 0x31, 0x1c, 0x75, 0x62, 0x7c, 0xc7, 0x66, 0x08, 0xfc, 0x67, 0x5b,
	0x9b, 0x4d, 0x63, 0x38, 0x32, 0x8a, 0x3f, 0x51, 0x21, 0x19, 0xdf, 0x2c, 0x24, 0xc9, 0xd1, 0x21,
	0x38, 0x4d, 0x7d, 0x1c, 0x9a, 0xd8, 0x60, 0x75, 0x51, 0xf4, 0x5a, 0xeb, 0xe8, 0xf5, 0xb5, 0xad,
	0x86, 0x5e, 0xab, 0x5a, 0xe0, 0x4a, 0xae, 0x19, 0xaf, 0x6b, 0x61, 0xa4, 0xe9, 0x3f, 0x7b, 0x30,
	0xae, 0x13, 0x47, 0x4f, 0x61, 0x82, 0x93, 0x5b, 0xc2, 0x25, 0x15, 0x84, 0x8b, 0xa0, 0x77, 0xe6,
	0xce, 0x26, 0xe7, 0x3f, 0x7a, 0xf5, 0x84, 0xf3, 0x8b, 0x16, 0xf5, 0xb4, 0x90, 0x7c, 0x13, 0x75,
	0xfd, 0xc2, 0x2b, 0xf0, 0xb7, 0x01, 0xc8, 0x07, 0xf7, 0x86, 0x6c, 0x6c, 0xe2, 0x6a, 0x89, 0x1e,
	0xc0, 0xe0, 0x16, 0x67, 0x95, 0x49, 0x7d, 0x72, 0xfe, 0x4e, 0xbb, 0x4d, 0xeb, 0x1c, 0x19, 0xc8,
	0x6f, 0x9c, 0x5f, 0xf5, 0xa6, 0xff, 0x76, 0x00, 0x5a, 0x8b, 0x3a, 0x64, 0x81, 0x73, 0x52, 0x57,
	0x51, 0xad, 0xd1, 0x05, 0x78, 0x31, 0xce, 0x4b, 0x4c, 0xd3, 0x42, 0x04, 0xce, 0x76, 0xf6, 0xad,
	0xf3, 0xfc, 0x49, 0x8d, 0x32, 0xd9, 0xb7, 0x5e, 0x3a, 0x04, 0x27, 0x58, 0xd2, 0x5b, 0x22, 0x02,
	0xf7, 0xbb, 0x42, 0xd4, 0xa8, 0x3a, 0x44, 0x2d, 0x87, 0xcf, 0xe1, 0xf0, 0x6e, 0xfc, 0x1d, 0x87,
	0x9f, 0xdd, 0x3d, 0x7c, 0xb7, 0x8b, 0xac, 0x6b, 0xe7, 0xe8, 0x3a, 0xe2, 0x9d, 0xed, 0xbe, 0x5f,
	0x44, 0xeb, 0xda, 0x2d, 0xe6, 0x7f, 0xfb, 0x30, 0xae, 0x77, 0xb2, 0x3d, 0xe5, 0x34, 0x3d, 0x75,
	0x87, 0x8a, 0xee, 0x16, 0x15, 0x77, 0xd5, 0xfd, 0xfd, 0x6e, 0xd1, 0xfa, 0x67, 0xee, 0xcc, 0xeb,
	0xd4, 0x03, 0x85, 0x30, 0x8e, 0xb1, 0x24, 0x29, 0xe3, 0x9b, 0x60, 0xa0, 0x8d, 0x8d, 0x8c, 0x1e,
	0xc3, 0xa8, 0xe4, 0x34, 0xa6, 0x45, 0x1a, 0x0c, 0x75, 0xde, 0xe1, 0xab, 0x95, 0x98, 0x3f, 0x37,
	0x88, 0xa8, 0x86, 0xa2, 0x47, 0x30, 0x5c, 0x55, 0x49, 0x4a, 0x64, 0x30, 0xd2, 0x4e, 0xef, 0xed,
	0x70, 0xfa, 0x5c, 0x03, 0x22, 0x0b, 0x44, 0x8f, 0xc0, 0x93, 0x98, 0xa7, 0x44, 0xaa, 0xad, 0xc6,
	0xda, 0xeb, 0xed, 0xd6, 0xeb, 0xaa, 0x36, 0x45, 0x2d, 0x0a, 0xcd, 0xc0, 0xcf, 0x70, 0x91, 0xd0,
	0x22, 0x5d, 0x96, 0x38, 0x25, 0xcb, 0x8a, 0x67, 0x81, 0xa7, 0xf3, 0x3f, 0xb4, 0xfa, 0xe7, 0x38,
	0x25, 0xdf, 0xf0, 0x0c, 0x7d, 0x02, 0x27, 0x34, 0x2f, 0x39, 0x11, 0x82, 0xb2, 0x62, 0x29, 0x39,
	0x8e, 0x6f, 0x94, 0x97, 0x72, 0x00, 0x5d, 0xa6, 0x77, 0x5b, 0xf3, 0x95, 0xb5, 0x2a, 0xbf, 0x0f,
	0x00, 0x84, 0xc4, 0x5c, 0x9a, 0xe1, 0x35, 0xd1, 0x50, 0x4f, 0x6b, 0xf4, 0xfc, 0x3a, 0x05, 0x4f,
	0x48, 0x56, 0x1a, 0xeb, 0x81, 0xb9, 0x07, 0xa5, 0xd0, 0xc6, 0x10, 0xc6, 0xb4, 0xc0, 0xb1, 0x2a,
	0x71, 0x70, 0xff, 0xac, 0x37, 0x1b, 0x47, 0x8d, 0x1c, 0xfe, 0x05, 0x46, 0xb6, 0x66, 0xba, 0xf8,
	0x15, 0xe7, 0xa4, 0x88, 0x37, 0xcd, 0x54, 0xb5, 0xb2, 0x6a, 0xa2, 0x95, 0xbd, 0xf8, 0x5e, 0xa4,
	0x96, 0xe8, 0x43, 0x80, 0x36, 0x53, 0x7d, 0xf5, 0xbd, 0xa8, 0xa3, 0x09, 0x3f, 0x84, 0xa1, 0xa9,
	0x2b, 0x7a, 0x07, 0x06, 0x09, 0xa6, 0x99, 0x09, 0xda, 0x8b, 0x8c, 0x30, 0xfd, 0x87, 0x0b, 0xc3,
	0xaf, 0xf4, 0xb5, 0xa3, 0x39, 0x0c, 0xb1, 0x10, 0x44, 0xd6, 0x63, 0xe4, 0xb8, 0xad, 0xb6, 0x41,
	0xcc, 0x2f, 0x94, 0x39, 0xb2, 0xa8, 0xf0, 0x5b, 0x07, 0x06, 0x5a, 0x83, 0xce, 0x61, 0x20, 0xa9,
	0xcc, 0x88, 0x9d, 0xb0, 0xef, 0xef, 0x76, 0x9c, 0x5f, 0x29, 0x4c, 0x64, 0xa0, 0xca, 0x87, 0xe6,
	0x38, 0xad, 0xbb, 0xff, 0x75, 0x3e, 0x0b, 0x85, 0x89, 0x0c, 0x14, 0x3d, 0xb4, 0x73, 0xd8, 0xd5,
	0x2e, 0xa7, 0xaf, 0x71, 0xf9, 0x02, 0x4b, 0x6c, 0x86, 0x74, 0x78, 0x0a, 0x03, 0xbd, 0xa9, 0xe2,
	0x80, 0x24, 0x7f, 0x97, 0x35, 0x07, 0xd4, 0x3a, 0xfc, 0x2b, 0x0c, 0x74, 0x74, 0x55, 0x55, 0x75,
	0xf1, 0x96, 0x9a, 0x15, 0xcf, 0x54, 0xad, 0x5e, 0xd0, 0x44, 0xae, 0x75, 0x72, 0x6e, 0x64, 0x04,
	0x35, 0x91, 0xd7, 0x84, 0xa6, 0x6b, 0xa9, 0x13, 0x70, 0x23, 0x2b, 0xa9, 0xe0, 0x39, 0xcd, 0x89,
	0x9d, 0xd3, 0x7a, 0x1d, 0xfe, 0x1c, 0xfa, 0x2a, 0x0f, 0x15, 0xc9, 0x90, 0xdc, 0x44, 0x37, 0x82,
	0x4e, 0x67, 0x53, 0x12, 0x1b, 0x5e, 0xaf, 0xa7, 0xdf, 0x2a, 0x82, 0x5b, 0x0a, 0xee, 0xe4, 0xec,
	0x36, 0xe9, 0xdf, 0x86, 0x01, 0x4e, 0x5a, 0xc2, 0xf7, 0x71, 0xb2, 0x48, 0x4c, 0x93, 0x09, 0x12,
	0x57, 0xdc, 0xe4, 0xa3, 0x9b, 0xcc, 0xc8, 0xe8, 0x81, 0xdd, 0x75, 0x70, 0xd6, 0x9b, 0x1d, 0x76,
	0xaf, 0xb7, 0xde, 0xf6, 0x6a, 0x53, 0x12, 0x93, 0x8d, 0x9d, 0x28, 0xf1, 0x8d, 0xa6, 0xc4, 0xb0,
	0x99, 0x28, 0xf1, 0x8d, 0x62, 0xc1, 0x4f, 0xa1, 0x2f, 0xe8, 0x4b, 0x62, 0xb9, 0x7c, 0xf2, 0x6a,
	0xa0, 0xf9, 0x25, 0x7d, 0x49, 0x22, 0x0d, 0x42, 0x3f, 0x84, 0x83, 0xb5, 0xcc, 0xb3, 0x65, 0xcc,
	0x0a, 0x49, 0x0a, 0xa9, 0xa9, 0xec, 0x45, 0x13, 0xa5, 0x7b, 0x62, 0x54, 0x2a, 0xe9, 0xa4, 0xe2,
	0x58, 0xaa, 0x16, 0xf6, 0x74, 0x49, 0x1a, 0x59, 0x15, 0x50, 0x15, 0x54, 0x04, 0xa0, 0x89, 0x6c,
	0x04, 0x35, 0xbf, 0xf4, 0xf7, 0x49, 0xcc, 0x32, 0x11, 0x4c, 0xce, 0xdc, 0x99, 0x1b, 0xb5, 0x0a,
	0xf4, 0x1e, 0x8c, 0x6f, 0xb1, 0x90, 0x3a, 0x77, 0xc3, 0xc2, 0x91, 0x92, 0x55, 0xea, 0x33, 0x18,
	0x16, 0xb8, 0xa1, 0xe0, 0xe4, 0xdc, 0xdf, 0x6e, 0xa2, 0xc8, 0xda, 0x15, 0xb3, 0xb0, 0x94, 0x9c,
	0xae, 0x2a, 0x49, 0x44, 0x70, 0xa8, 0xf7, 0xe8, 0x68, 0x94, 0x5d, 0xdc, 0xd0, 0x92, 0x5d, 0x5f,
	0x0b, 0x22, 0x83, 0xb7, 0x74, 0xda, 0x1d, 0x0d, 0xfa, 0x01, 0x4c, 0x4c, 0x05, 0x73, 0x1c, 0x73,
	0x16, 0xf8, 0x3a, 0x0f, 0xd0, 0xaa, 0x2f, 0x95, 0x06, 0x7d, 0x04, 0x6f, 0x75, 0x00, 0x4b, 0x22,
	0xe2, 0xe0, 0x48, 0x83, 0xee, 0xb7, 0xa0, 0xa7, 0x22, 0x0e, 0x1f, 0x43, 0x5f, 0x95, 0xb3, 0x6d,
	0xca, 0xde, 0xee, 0xa6, 0x74, 0xba, 0x4d, 0x39, 0xfd, 0x9f, 0x07, 0x5e, 0x33, 0x24, 0xd1, 0x4f,
	0xc0, 0x4d, 0x09, 0xb3, 0xfc, 0x3c, 0xd9, 0x31, 0x46, 0xe7, 0xcf, 0x08, 0x8b, 0x14, 0x06, 0x7d,
	0x04, 0x0e, 0xab, 0xdf, 0xe2, 0xe3, 0x5d, 0xc8, 0xaf, 0x2f, 0x23, 0x87, 0xe9, 0x2b, 0xb8, 0xe6,
	0xea, 0xc3, 0x47, 0x0d, 0x2a, 0x43, 0x88, 0x56, 0x81, 0x7e, 0x07, 0x50, 0x09, 0xc2, 0x97, 0x38,
	0x55, 0x77, 0xde, 0xd7, 0xfb, 0x7e, 0xb0, 0x2b, 0xda, 0x37, 0x82, 0xf0, 0x0b, 0x05, 0x8a, 0xbc,
	0xaa, 0x5e, 0xa2, 0x4f, 0x61, 0x14, 0x63, 0xce, 0x29, 0xe1, 0xba, 0x59, 0x5f, 0xe3, 0xfa, 0x67,
	0x2a, 0xe4, 0x97, 0x58, 0xc6, 0xeb, 0xa8, 0x46, 0xa3, 0x87, 0xe0, 0xc6, 0x58, 0xda, 0x97, 0x69,
	0x8f, 0x93, 0x42, 0xa2, 0xdf, 0xc3, 0x24, 0x21, 0xb7, 0x34, 0x26, 0x4b, 0x4d, 0x8d, 0xd1, 0x9b,
	0x38, 0x82, 0xf1, 0x50, 0x6c, 0x41, 0xbf, 0x84, 0x61, 0xc2, 0x72, 0x4c, 0x0b, 0xfb, 0x44, 0xed,
	0x71, 0xb5, 0x60, 0xf4, 0x5b, 0xf0, 0xca, 0x6a, 0x95, 0x51, 0xb1, 0x26, 0x5c, 0xb7, 0xfc, 0x5e,
	0xcf, 0x16, 0xaf, 0x0e, 0x29, 0x44, 0xa9, 0x1f, 0xaa, 0xfd, 0x87, 0x14, 0xa2, 0x44, 0xe7, 0x30,
	0x4c, 0x19, 0x4b, 0x33, 0xf3, 0x62, 0xdd, 0x79, 0xb2, 0x3b, 0x0d, 0xa0, 0x11, 0x91, 0x45, 0xaa,
	0x2b, 0x28, 0x88, 0x7c, 0xc1, 0xf8, 0x8d, 0xa6, 0xd0, 0xfe, 0x2b, 0xb0, 0x68, 0xf4, 0x33, 0x70,
	0x68, 0x69, 0xd9, 0xb5, 0xc7, 0xc7, 0xa1, 0xa5, 0xe2, 0x2a, 0xc7, 0x45, 0x4a, 0x96, 0xb4, 0xd4,
	0x24, 0xf3, 0xa2, 0x91, 0x96, 0x17, 0x25, 0xfa, 0x03, 0x1c, 0x54, 0xdc, 0x0c, 0x0e, 0x4c, 0x0b,
	0xa1, 0x39, 0xb6, 0x37, 0xe6, 0xa4, 0xe2, 0x7a, 0xae, 0x28, 0x0f, 0xf4, 0x09, 0x8c, 0x04, 0x95,
	0x44, 0x0d, 0x49, 0xff, 0x8d, 0xae, 0x47, 0xa1, 0x17, 0x09, 0x7a, 0x0c, 0x43, 0x5c, 0x96, 0xca,
	0xed, 0xe8, 0x4d, 0xdc, 0x06, 0xb8, 0x2c, 0x17, 0x49, 0xf8, 0x31, 0x0c, 0x4d, 0x11, 0xd5, 0x67,
	0xc2, 0x8a, 0x66, 0x99, 0xfa, 0xa4, 0x68, 0xbe, 0xfd, 0x3d, 0xab, 0x59, 0x24, 0xe1, 0xbf, 0x7a,
	0xe0, 0x3e, 0x23, 0x4c, 0xb7, 0x39, 0xab, 0xd4, 0xe7, 0xa1, 0x65, 0xe6, 0xde, 0x36, 0x37, 0x68,
	0xf4, 0x08, 0xfa, 0x31, 0x95, 0x1b, 0xfb, 0x76, 0xee, 0xf1, 0xd2, 0x50, 0xd5, 0xa8, 0x9c, 0xa4,
	0xf5, 0x47, 0xc2, 0xfe, 0x4a, 0x18, 0x70, 0x78, 0x0e, 0xce, 0xd7, 0x97, 0x3b, 0x9f, 0xa3, 0x00,
	0x46, 0xb7, 0x84, 0xeb, 0xcf, 0x0e, 0xc7, 0xce, 0x58, 0x23, 0x86, 0x9f, 0x82, 0xd7, 0xb0, 0x7a,
	0xa7, 0xeb, 0x31, 0x0c, 0x73, 0xb6, 0xa2, 0x99, 0x79, 0x00, 0xc7, 0x91, 0x95, 0xc2, 0x5f, 0x83,
	0xd7, 0x64, 0xa0, 0xe2, 0xd3, 0x22, 0xce, 0xaa, 0xc4, 0xf8, 0x8e, 0xa3, 0x5a, 0x54, 0x21, 0x33,
	0x2a, 0xa4, 0x9e, 0x51, 0x5e, 0xa4, 0xd7, 0x0f, 0x38, 0x1c, 0x74, 0x5f, 0x31, 0x74, 0x0c, 0x48,
	0xae, 0x29, 0x4f, 0x96, 0x25, 0xe6, 0x72, 0xb3, 0x5c, 0xe1, 0xa2, 0x20, 0xdc, 0xbf, 0x87, 0xde,
	0x85, 0xa3, 0xae, 0xfe, 0x96, 0x26, 0x84, 0xf9, 0x3d, 0x04, 0xf5, 0xb3, 0xe0, 0x3b, 0x6a, 0x6d,
	0xe1, 0x2e, 0xf2, 0xe1, 0x80, 0x16, 0x92, 0x70, 0x21, 0xa9, 0xa4, 0x38, 0xf3, 0xfb, 0xc8, 0x83,
	0x81, 0x71, 0x1a, 0x3c, 0xb8, 0x84, 0xd1, 0x57, 0xb6, 0xe9, 0xef, 0x83, 0xb7, 0xa2, 0x89, 0x78,
	0x41, 0x65, 0xbc, 0xf6, 0xef, 0xa9, 0x10, 0x86, 0x46, 0x7e, 0x0f, 0x8d, 0xd5, 0xd7, 0x01, 0x17,
	0xbe, 0x83, 0x0e, 0x60, 0x8c, 0x93, 0xdb, 0x1c, 0xdf, 0xe8, 0xd0, 0x07, 0x30, 0x16, 0x39, 0xe6,
	0x92, 0xcb, 0x95, 0xdf, 0x47, 0x23, 0x70, 0x99, 0xcc, 0xfd, 0xc1, 0xf9, 0x7f, 0x7a, 0xe0, 0x5e,
	0x3c, 0x5f, 0xa0, 0xcf, 0x60, 0x68, 0x7e, 0x79, 0x51, 0x67, 0x5c, 0xdf, 0xf9, 0x01, 0x0f, 0x83,
	0x57, 0x0d, 0xe6, 0x87, 0x75, 0x7a, 0x0f, 0xfd, 0x11, 0xbc, 0xe6, 0x3f, 0x16, 0x75, 0xf8, 0xbe,
	0xfd, 0x83, 0x1c, 0x9e, 0xee, 0xb4, 0x35, 0x71, 0x3e, 0x03, 0xef, 0xd9, 0xae, 0x38, 0xdb, 0xff,
	0xbe, 0xe1, 0x8e, 0xdf, 0xea, 0xe9, 0xbd, 0xd5, 0x50, 0x3f, 0xca, 0xbf, 0xf8, 0x7f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xf1, 0x11, 0xe3, 0xba, 0x60, 0x10, 0x00, 0x00,
}
